Message-ID: <CAJ+kdVF-2xTBx3t=BBfeozkwaZQFfjcsuUr_e1Pue25d7+-PCA@mail.gmail.com>
Subject: [PATCH] media: sun6i-csi: Limit formats to those compatible with
 sub-device

To make format enumeration useful it needs to be limited to the formats
that are valid for the currently linked sub-device.
---
 .../platform/sunxi/sun6i-csi/sun6i_csi.c      | 158 ++++++---------
 .../platform/sunxi/sun6i-csi/sun6i_csi.h      |  23 ++-
 .../platform/sunxi/sun6i-csi/sun6i_video.c    | 180 ++++++++++--------
 3 files changed, 178 insertions(+), 183 deletions(-)

diff --git a/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.c
b/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.c
index 44e18419f4cf..3098ff118eb7 100644
--- a/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.c
+++ b/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.c
@@ -46,12 +46,58 @@ static inline struct sun6i_csi_dev
*sun6i_csi_to_dev(struct sun6i_csi *csi)
     return container_of(csi, struct sun6i_csi_dev, csi);
 }

+static u32 yuv_pixelformats[] = {
+    V4L2_PIX_FMT_HM12,
+    V4L2_PIX_FMT_NV12,
+    V4L2_PIX_FMT_NV21,
+    V4L2_PIX_FMT_NV16,
+    V4L2_PIX_FMT_NV61,
+    V4L2_PIX_FMT_YUV420,
+    V4L2_PIX_FMT_YVU420,
+    V4L2_PIX_FMT_YUV422P,
+};
+
+static struct sun6i_csi_mode wide_bus_modes[] = {
+    { MEDIA_BUS_FMT_UYVY8_1X16, yuv_pixelformats,
ARRAY_SIZE(yuv_pixelformats) },
+    { MEDIA_BUS_FMT_VYUY8_1X16, yuv_pixelformats,
ARRAY_SIZE(yuv_pixelformats) },
+    { MEDIA_BUS_FMT_YUYV8_1X16, yuv_pixelformats,
ARRAY_SIZE(yuv_pixelformats) },
+    { MEDIA_BUS_FMT_YVYU8_1X16, yuv_pixelformats,
ARRAY_SIZE(yuv_pixelformats) },
+};
+
+static struct sun6i_csi_mode modes[] = {
+    { MEDIA_BUS_FMT_SBGGR8_1X8, (u32[]) { V4L2_PIX_FMT_SBGGR8 }, 1 },
+    { MEDIA_BUS_FMT_SGBRG8_1X8, (u32[]) { V4L2_PIX_FMT_SGBRG8 }, 1 },
+    { MEDIA_BUS_FMT_SGRBG8_1X8, (u32[]) { V4L2_PIX_FMT_SGRBG8 }, 1 },
+    { MEDIA_BUS_FMT_SRGGB8_1X8, (u32[]) { V4L2_PIX_FMT_SRGGB8 }, 1 },
+    { MEDIA_BUS_FMT_SBGGR10_1X10, (u32[]) { V4L2_PIX_FMT_SBGGR10 }, 1 },
+    { MEDIA_BUS_FMT_SGBRG10_1X10, (u32[]) { V4L2_PIX_FMT_SGBRG10 }, 1 },
+    { MEDIA_BUS_FMT_SGRBG10_1X10, (u32[]) { V4L2_PIX_FMT_SGRBG10 }, 1 },
+    { MEDIA_BUS_FMT_SRGGB10_1X10, (u32[]) { V4L2_PIX_FMT_SRGGB10 }, 1 },
+    { MEDIA_BUS_FMT_SBGGR12_1X12, (u32[]) { V4L2_PIX_FMT_SBGGR12 }, 1 },
+    { MEDIA_BUS_FMT_SGBRG12_1X12, (u32[]) { V4L2_PIX_FMT_SGBRG12 }, 1 },
+    { MEDIA_BUS_FMT_SGRBG12_1X12, (u32[]) { V4L2_PIX_FMT_SGRBG12 }, 1 },
+    { MEDIA_BUS_FMT_SRGGB12_1X12, (u32[]) { V4L2_PIX_FMT_SRGGB12 }, 1 },
+    { MEDIA_BUS_FMT_YUYV8_2X8, (u32[]) { V4L2_PIX_FMT_YUYV }, 1 },
+    { MEDIA_BUS_FMT_YVYU8_2X8, (u32[]) { V4L2_PIX_FMT_YVYU }, 1 },
+    { MEDIA_BUS_FMT_UYVY8_2X8, (u32[]) { V4L2_PIX_FMT_UYVY }, 1 },
+    { MEDIA_BUS_FMT_VYUY8_2X8, (u32[]) { V4L2_PIX_FMT_VYUY }, 1 },
+    { MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE, (u32[]) { V4L2_PIX_FMT_RGB555 }, 1 },
+    { MEDIA_BUS_FMT_UYVY8_2X8, yuv_pixelformats,
ARRAY_SIZE(yuv_pixelformats) },
+    { MEDIA_BUS_FMT_VYUY8_2X8, yuv_pixelformats,
ARRAY_SIZE(yuv_pixelformats) },
+    { MEDIA_BUS_FMT_YUYV8_2X8, yuv_pixelformats,
ARRAY_SIZE(yuv_pixelformats) },
+    { MEDIA_BUS_FMT_YVYU8_2X8, yuv_pixelformats,
ARRAY_SIZE(yuv_pixelformats) },
+    { MEDIA_BUS_FMT_RGB565_2X8_LE, (u32[]) { V4L2_PIX_FMT_RGB565 }, 1 },
+    { MEDIA_BUS_FMT_RGB565_2X8_BE, (u32[]) { V4L2_PIX_FMT_RGB565X }, 1 },
+    { MEDIA_BUS_FMT_JPEG_1X8, (u32[]) { V4L2_PIX_FMT_JPEG }, 1 },
+};
+
 /* TODO add 10&12 bit YUV, RGB support */
-bool sun6i_csi_is_format_supported(struct sun6i_csi *csi,
-                   u32 pixformat, u32 mbus_code,
-                   struct v4l2_fwnode_endpoint* vep)
+bool sun6i_csi_get_pixelformats(u32 mbus_code,
+                struct v4l2_fwnode_endpoint* vep,
+                u32 **pixelformats,
+                u32 *pixelformats_size)
 {
-    struct sun6i_csi_dev *sdev = sun6i_csi_to_dev(csi);
+    u32 i;

     /*
      * Some video receivers have the ability to be compatible with
@@ -59,109 +105,25 @@ bool sun6i_csi_is_format_supported(struct sun6i_csi *csi,
      * Identify the media bus format from device tree.
      */
     if ((vep->bus_type == V4L2_MBUS_PARALLEL
-         || vep->bus_type == V4L2_MBUS_BT656)
-         && vep->bus.parallel.bus_width == 16) {
-        switch (pixformat) {
-        case V4L2_PIX_FMT_HM12:
-        case V4L2_PIX_FMT_NV12:
-        case V4L2_PIX_FMT_NV21:
-        case V4L2_PIX_FMT_NV16:
-        case V4L2_PIX_FMT_NV61:
-        case V4L2_PIX_FMT_YUV420:
-        case V4L2_PIX_FMT_YVU420:
-        case V4L2_PIX_FMT_YUV422P:
-            switch (mbus_code) {
-            case MEDIA_BUS_FMT_UYVY8_1X16:
-            case MEDIA_BUS_FMT_VYUY8_1X16:
-            case MEDIA_BUS_FMT_YUYV8_1X16:
-            case MEDIA_BUS_FMT_YVYU8_1X16:
+        || vep->bus_type == V4L2_MBUS_BT656)
+        && vep->bus.parallel.bus_width == 16) {
+        for (i = 0; i < ARRAY_SIZE(wide_bus_modes); ++i) {
+            if (modes[i].mbus_code == mbus_code) {
+                *pixelformats = modes[i].pixelformats;
+                *pixelformats_size = modes[i].pixelformats_size;
                 return true;
-            default:
-                dev_dbg(sdev->dev, "Unsupported mbus code: 0x%x\n",
-                    mbus_code);
-                break;
             }
-            break;
-        default:
-            dev_dbg(sdev->dev, "Unsupported pixformat: 0x%x\n",
-                pixformat);
-            break;
         }
         return false;
     }

-    switch (pixformat) {
-    case V4L2_PIX_FMT_SBGGR8:
-        return (mbus_code == MEDIA_BUS_FMT_SBGGR8_1X8);
-    case V4L2_PIX_FMT_SGBRG8:
-        return (mbus_code == MEDIA_BUS_FMT_SGBRG8_1X8);
-    case V4L2_PIX_FMT_SGRBG8:
-        return (mbus_code == MEDIA_BUS_FMT_SGRBG8_1X8);
-    case V4L2_PIX_FMT_SRGGB8:
-        return (mbus_code == MEDIA_BUS_FMT_SRGGB8_1X8);
-    case V4L2_PIX_FMT_SBGGR10:
-        return (mbus_code == MEDIA_BUS_FMT_SBGGR10_1X10);
-    case V4L2_PIX_FMT_SGBRG10:
-        return (mbus_code == MEDIA_BUS_FMT_SGBRG10_1X10);
-    case V4L2_PIX_FMT_SGRBG10:
-        return (mbus_code == MEDIA_BUS_FMT_SGRBG10_1X10);
-    case V4L2_PIX_FMT_SRGGB10:
-        return (mbus_code == MEDIA_BUS_FMT_SRGGB10_1X10);
-    case V4L2_PIX_FMT_SBGGR12:
-        return (mbus_code == MEDIA_BUS_FMT_SBGGR12_1X12);
-    case V4L2_PIX_FMT_SGBRG12:
-        return (mbus_code == MEDIA_BUS_FMT_SGBRG12_1X12);
-    case V4L2_PIX_FMT_SGRBG12:
-        return (mbus_code == MEDIA_BUS_FMT_SGRBG12_1X12);
-    case V4L2_PIX_FMT_SRGGB12:
-        return (mbus_code == MEDIA_BUS_FMT_SRGGB12_1X12);
-
-    case V4L2_PIX_FMT_YUYV:
-        return (mbus_code == MEDIA_BUS_FMT_YUYV8_2X8);
-    case V4L2_PIX_FMT_YVYU:
-        return (mbus_code == MEDIA_BUS_FMT_YVYU8_2X8);
-    case V4L2_PIX_FMT_UYVY:
-        return (mbus_code == MEDIA_BUS_FMT_UYVY8_2X8);
-    case V4L2_PIX_FMT_VYUY:
-        return (mbus_code == MEDIA_BUS_FMT_VYUY8_2X8);
-
-    case V4L2_PIX_FMT_RGB555:
-        return mbus_code == MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE;
-
-    case V4L2_PIX_FMT_HM12:
-    case V4L2_PIX_FMT_NV12:
-    case V4L2_PIX_FMT_NV21:
-    case V4L2_PIX_FMT_NV16:
-    case V4L2_PIX_FMT_NV61:
-    case V4L2_PIX_FMT_YUV420:
-    case V4L2_PIX_FMT_YVU420:
-    case V4L2_PIX_FMT_YUV422P:
-        switch (mbus_code) {
-        case MEDIA_BUS_FMT_UYVY8_2X8:
-        case MEDIA_BUS_FMT_VYUY8_2X8:
-        case MEDIA_BUS_FMT_YUYV8_2X8:
-        case MEDIA_BUS_FMT_YVYU8_2X8:
+    for (i = 0; i < ARRAY_SIZE(modes); ++i) {
+        if (modes[i].mbus_code == mbus_code) {
+            *pixelformats = modes[i].pixelformats;
+            *pixelformats_size = modes[i].pixelformats_size;
             return true;
-        default:
-            dev_dbg(sdev->dev, "Unsupported mbus code: 0x%x\n",
-                mbus_code);
-            break;
         }
-        break;
-
-    case V4L2_PIX_FMT_RGB565:
-        return (mbus_code == MEDIA_BUS_FMT_RGB565_2X8_LE);
-    case V4L2_PIX_FMT_RGB565X:
-        return (mbus_code == MEDIA_BUS_FMT_RGB565_2X8_BE);
-
-    case V4L2_PIX_FMT_JPEG:
-        return (mbus_code == MEDIA_BUS_FMT_JPEG_1X8);
-
-    default:
-        dev_dbg(sdev->dev, "Unsupported pixformat: 0x%x\n", pixformat);
-        break;
     }
-
     return false;
 }

diff --git a/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.h
b/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.h
index 3be680938255..c2bdeb5ec21f 100644
--- a/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.h
+++ b/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.h
@@ -48,16 +48,23 @@ struct sun6i_csi_async_subdev {
     struct v4l2_fwnode_endpoint    vep;
 };

+struct sun6i_csi_mode {
+    u32    mbus_code;
+    u32    *pixelformats;
+    u32    pixelformats_size;
+};
+
 /**
- * sun6i_csi_is_format_supported() - check if the format supported by csi
- * @csi:    pointer to the csi
- * @pixformat:    v4l2 pixel format (V4L2_PIX_FMT_*)
- * @mbus_code:    media bus format code (MEDIA_BUS_FMT_*)
- * @vep:        parsed CSI side bus endpoint configuration
+ * sun6i_csi_get_pixelformats() - get the valid pixel formats for a bus code
+ * @mbus_code:        the bus code
+ * @vep:        parsed CSI side bus endpoint configuration
+ * @pixelformats:    returned list of valid pixel formats
+ * @pixelformats_size:    size of pixelformats
  */
-bool sun6i_csi_is_format_supported(struct sun6i_csi *csi,
-                   u32 pixformat, u32 mbus_code,
-                   struct v4l2_fwnode_endpoint* vep);
+bool sun6i_csi_get_pixelformats(u32 mbus_code,
+                struct v4l2_fwnode_endpoint* vep,
+                u32 **pixelformats,
+                u32 *pixelformats_size);

 /**
  * sun6i_csi_set_power() - power on/off the csi
diff --git a/drivers/media/platform/sunxi/sun6i-csi/sun6i_video.c
b/drivers/media/platform/sunxi/sun6i-csi/sun6i_video.c
index 23fb296e1d0c..8b3c9f944106 100644
--- a/drivers/media/platform/sunxi/sun6i-csi/sun6i_video.c
+++ b/drivers/media/platform/sunxi/sun6i-csi/sun6i_video.c
@@ -31,44 +31,14 @@ struct sun6i_csi_buffer {
     bool                queued_to_csi;
 };

-static const u32 supported_pixformats[] = {
-    V4L2_PIX_FMT_SBGGR8,
-    V4L2_PIX_FMT_SGBRG8,
-    V4L2_PIX_FMT_SGRBG8,
-    V4L2_PIX_FMT_SRGGB8,
-    V4L2_PIX_FMT_SBGGR10,
-    V4L2_PIX_FMT_SGBRG10,
-    V4L2_PIX_FMT_SGRBG10,
-    V4L2_PIX_FMT_SRGGB10,
-    V4L2_PIX_FMT_SBGGR12,
-    V4L2_PIX_FMT_SGBRG12,
-    V4L2_PIX_FMT_SGRBG12,
-    V4L2_PIX_FMT_SRGGB12,
-    V4L2_PIX_FMT_YUYV,
-    V4L2_PIX_FMT_YVYU,
-    V4L2_PIX_FMT_UYVY,
-    V4L2_PIX_FMT_VYUY,
-    V4L2_PIX_FMT_RGB565,
-    V4L2_PIX_FMT_RGB555,
-    V4L2_PIX_FMT_HM12,
-    V4L2_PIX_FMT_NV12,
-    V4L2_PIX_FMT_NV21,
-    V4L2_PIX_FMT_YUV420,
-    V4L2_PIX_FMT_YVU420,
-    V4L2_PIX_FMT_NV16,
-    V4L2_PIX_FMT_NV61,
-    V4L2_PIX_FMT_YUV422P,
-    V4L2_PIX_FMT_RGB565,
-    V4L2_PIX_FMT_RGB565X,
-    V4L2_PIX_FMT_JPEG,
-};
-
-static bool is_pixformat_valid(unsigned int pixformat)
+static bool is_pixformat_valid(u32 pixformat,
+                   u32 *pixformats,
+                   u32 pixelformats_size)
 {
-    unsigned int i;
+    u32 i;

-    for (i = 0; i < ARRAY_SIZE(supported_pixformats); i++)
-        if (supported_pixformats[i] == pixformat)
+    for (i = 0; i < pixelformats_size; i++)
+        if (pixformats[i] == pixformat)
             return true;

     return false;
@@ -331,38 +301,90 @@ static int vidioc_querycap(struct file *file, void *priv,
     return 0;
 }

-static int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,
-                   struct v4l2_fmtdesc *f)
+static int sun6i_get_available_formats(struct sun6i_video *video,
+                       u32 **pixelformats,
+                       u32 *pixelformats_size,
+                       struct v4l2_subdev_format *subdev_format)
 {
-    u32 index = f->index;
+    struct v4l2_subdev *sd;
+    u32 sd_pad;
+    struct sun6i_csi_async_subdev* casd;
+    struct v4l2_subdev_format source_fmt = {};
+    int ret;

-    if (index >= ARRAY_SIZE(supported_pixformats))
-        return -EINVAL;
+    sd = sun6i_video_remote_subdev(video, &sd_pad);
+    if (!sd)
+        return -EPIPE;
+
+    casd = container_of(sd->asd, struct sun6i_csi_async_subdev, asd);

-    f->pixelformat = supported_pixformats[index];
+    // Get format from subdev
+    source_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+    source_fmt.pad = sd_pad;
+
+    ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &source_fmt);
+    if (ret < 0)
+        return ret;
+
+    // Get pixelformats compatible with the subdev bus format
+    if (!sun6i_csi_get_pixelformats(source_fmt.format.code,
+                    &casd->vep,
+                    pixelformats,
+                    pixelformats_size)) {
+        return -EPIPE;
+    }
+
+    if (subdev_format)
+        *subdev_format = source_fmt;

     return 0;
 }

-static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
-                struct v4l2_format *fmt)
+static int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,
+                   struct v4l2_fmtdesc *f)
 {
     struct sun6i_video *video = video_drvdata(file);
+    u32 index = f->index;
+    u32 *pixelformats, pixelformats_size;
+    int ret;

-    *fmt = video->fmt;
+    ret = sun6i_get_available_formats(video,
+                      &pixelformats,
+                      &pixelformats_size,
+                      NULL);
+    if (ret < 0)
+        return ret;
+
+    if (index >= pixelformats_size)
+        return -EINVAL;
+
+    f->pixelformat = pixelformats[index];

     return 0;
 }

 static int sun6i_video_try_fmt(struct sun6i_video *video,
-                   struct v4l2_format *f)
+                   struct v4l2_format *f,
+                   struct v4l2_subdev_format *subdev_format)
 {
     struct v4l2_pix_format *pixfmt = &f->fmt.pix;
     int bpp;
     u32 bpl_packed;
+    int ret;
+    u32 *pixelformats, pixelformats_size;
+
+    ret = sun6i_get_available_formats(video,
+                      &pixelformats,
+                      &pixelformats_size,
+                      subdev_format);
+    if (ret)
+        return ret;

-    if (!is_pixformat_valid(pixfmt->pixelformat))
-        pixfmt->pixelformat = supported_pixformats[0];
+    if (!is_pixformat_valid(pixfmt->pixelformat,
+                pixelformats,
+                pixelformats_size)) {
+        pixfmt->pixelformat = pixelformats[0];
+    }

     v4l_bound_align_image(&pixfmt->width, MIN_WIDTH, MAX_WIDTH, 1,
                   &pixfmt->height, MIN_HEIGHT, MAX_WIDTH, 1, 1);
@@ -388,11 +410,28 @@ static int sun6i_video_try_fmt(struct sun6i_video *video,
     return 0;
 }

+static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
+                struct v4l2_format *fmt)
+{
+    struct sun6i_video *video = video_drvdata(file);
+    int ret;
+
+    // Let the try_fmt set the video format to something available before
+    // returning, as the subdev may change it's bus format in-between calls.
+    ret = sun6i_video_try_fmt(video, &video->fmt, NULL);
+    if (ret < 0)
+        return ret;
+
+    *fmt = video->fmt;
+
+    return 0;
+}
+
 static int sun6i_video_set_fmt(struct sun6i_video *video, struct
v4l2_format *f)
 {
     int ret;

-    ret = sun6i_video_try_fmt(video, f);
+    ret = sun6i_video_try_fmt(video, f, NULL);
     if (ret)
         return ret;

@@ -417,7 +456,7 @@ static int vidioc_try_fmt_vid_cap(struct file
*file, void *priv,
 {
     struct sun6i_video *video = video_drvdata(file);

-    return sun6i_video_try_fmt(video, f);
+    return sun6i_video_try_fmt(video, f, NULL);
 }

 static int vidioc_enum_framesizes(struct file *file, void *priv,
@@ -613,10 +652,6 @@ static int sun6i_video_link_validate(struct
media_link *link)
 {
     struct video_device *vdev = container_of(link->sink->entity,
                          struct video_device, entity);
-    struct v4l2_subdev *sd =
-            media_entity_to_v4l2_subdev(link->source->entity);
-    struct sun6i_csi_async_subdev* casd =
-            container_of(sd->asd, struct sun6i_csi_async_subdev, asd);
     struct sun6i_video *video = video_get_drvdata(vdev);
     struct v4l2_subdev_format source_fmt = {};
     int ret;
@@ -632,24 +667,10 @@ static int sun6i_video_link_validate(struct
media_link *link)
     if (!is_media_entity_v4l2_subdev(link->source->entity))
         return -EINVAL;

-    source_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
-    source_fmt.pad = link->source->index;
-
-    ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &source_fmt);
+    ret = sun6i_video_try_fmt(video, &video->fmt, &source_fmt);
     if (ret < 0)
         return ret;

-    if (!sun6i_csi_is_format_supported(video->csi,
-                       video->fmt.fmt.pix.pixelformat,
-                       source_fmt.format.code,
-                       &casd->vep)) {
-        dev_err(video->csi->dev,
-            "Unsupported pixformat: 0x%x with mbus code: 0x%x!\n",
-            video->fmt.fmt.pix.pixelformat,
-            source_fmt.format.code);
-        return -EPIPE;
-    }
-
     if (source_fmt.format.width != video->fmt.fmt.pix.width ||
         source_fmt.format.height != video->fmt.fmt.pix.height) {
         dev_err(video->csi->dev,
@@ -705,14 +726,6 @@ int sun6i_video_init(struct sun6i_video *video,
struct sun6i_csi *csi,

     video->sequence = 0;

-    /* Setup default format */
-    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    fmt.fmt.pix.pixelformat = supported_pixformats[0];
-    fmt.fmt.pix.width = 1280;
-    fmt.fmt.pix.height = 720;
-    fmt.fmt.pix.field = V4L2_FIELD_NONE;
-    sun6i_video_set_fmt(video, &fmt);
-
     /* Initialize videobuf2 queue */
     vidq->type            = V4L2_BUF_TYPE_VIDEO_CAPTURE;
     vidq->io_modes            = VB2_MMAP | VB2_DMABUF;
@@ -745,6 +758,19 @@ int sun6i_video_init(struct sun6i_video *video,
struct sun6i_csi *csi,
     vdev->device_caps    = V4L2_CAP_STREAMING |
V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_IO_MC;
     video_set_drvdata(vdev, video);

+    /* Setup default format */
+    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_SBGGR8;
+    fmt.fmt.pix.width = 1280;
+    fmt.fmt.pix.height = 720;
+    fmt.fmt.pix.field = V4L2_FIELD_NONE;
+    fmt.fmt.pix.sizeimage = fmt.fmt.pix.width * fmt.fmt.pix.height;
+    fmt.fmt.pix.colorspace = V4L2_COLORSPACE_RAW;
+    fmt.fmt.pix.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+    fmt.fmt.pix.quantization = V4L2_QUANTIZATION_DEFAULT;
+    fmt.fmt.pix.xfer_func = V4L2_XFER_FUNC_DEFAULT;
+    video->fmt = fmt;
+
     ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
     if (ret < 0) {
         v4l2_err(&csi->v4l2_dev,
-- 
2.25.1
