--- a/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.h	2022-06-29 21:05:35.789133283 +0300
+++ b/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.h	2022-06-29 21:09:57.631771474 +0300
@@ -48,6 +48,13 @@
 	struct v4l2_fwnode_endpoint	vep;
 };
 
+struct sun6i_csi_mode {
+    u32    mbus_code;
+    u32    *pixelformats;
+    u32    pixelformats_size;
+};
+
+
 /**
  * sun6i_csi_is_format_supported() - check if the format supported by csi
  * @csi:	pointer to the csi
@@ -67,14 +74,16 @@
 int sun6i_csi_set_power(struct sun6i_csi *csi, bool enable);
 
 /**
- * sun6i_csi_update_config() - update the csi register settings
- * @csi:	pointer to the csi
- * @config:	see struct sun6i_csi_config
+ * sun6i_csi_get_pixelformats() - get the valid pixel formats for a bus code
+ * @mbus_code:        the bus code
  * @vep:        parsed CSI side bus endpoint configuration
+ * @pixelformats:    returned list of valid pixel formats
+ * @pixelformats_size:    size of pixelformats1
  */
-int sun6i_csi_update_config(struct sun6i_csi *csi,
-			    struct sun6i_csi_config *config,
-			    struct v4l2_fwnode_endpoint* vep);
+bool sun6i_csi_get_pixelformats(u32 mbus_code,
+                struct v4l2_fwnode_endpoint* vep,
+                u32 **pixelformats,
+                u32 *pixelformats_size);
 
 /**
  * sun6i_csi_update_buf_addr() - update the csi frame buffer address
--- a/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.c	2022-06-29 21:04:49.678116490 +0300
+++ b/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.c	2022-06-29 21:18:47.165622958 +0300
@@ -46,12 +46,67 @@
 	return container_of(csi, struct sun6i_csi_dev, csi);
 }
 
+static u32 yuv_pixelformats[] = {
+    V4L2_PIX_FMT_HM12,
+    V4L2_PIX_FMT_NV12,
+    V4L2_PIX_FMT_NV21,
+    V4L2_PIX_FMT_NV16,
+    V4L2_PIX_FMT_NV61,
+    V4L2_PIX_FMT_YUV420,
+    V4L2_PIX_FMT_YVU420,
+    V4L2_PIX_FMT_YUV422P,
+};
+
+static struct sun6i_csi_mode wide_bus_modes[] = {
+    { MEDIA_BUS_FMT_UYVY8_1X16, yuv_pixelformats,
+ARRAY_SIZE(yuv_pixelformats) },
+    { MEDIA_BUS_FMT_VYUY8_1X16, yuv_pixelformats,
+ARRAY_SIZE(yuv_pixelformats) },
+    { MEDIA_BUS_FMT_YUYV8_1X16, yuv_pixelformats,
+ARRAY_SIZE(yuv_pixelformats) },
+    { MEDIA_BUS_FMT_YVYU8_1X16, yuv_pixelformats,
+ARRAY_SIZE(yuv_pixelformats) },
+};
+
+static struct sun6i_csi_mode modes[] = {
+	{ MEDIA_BUS_FMT_SBGGR8_1X8, (u32[]) { V4L2_PIX_FMT_SBGGR8 }, 1 },
+    { MEDIA_BUS_FMT_SGBRG8_1X8, (u32[]) { V4L2_PIX_FMT_SGBRG8 }, 1 },
+    { MEDIA_BUS_FMT_SGRBG8_1X8, (u32[]) { V4L2_PIX_FMT_SGRBG8 }, 1 },
+    { MEDIA_BUS_FMT_SRGGB8_1X8, (u32[]) { V4L2_PIX_FMT_SRGGB8 }, 1 },
+    { MEDIA_BUS_FMT_SBGGR10_1X10, (u32[]) { V4L2_PIX_FMT_SBGGR10 }, 1 },
+    { MEDIA_BUS_FMT_SGBRG10_1X10, (u32[]) { V4L2_PIX_FMT_SGBRG10 }, 1 },
+    { MEDIA_BUS_FMT_SGRBG10_1X10, (u32[]) { V4L2_PIX_FMT_SGRBG10 }, 1 },
+    { MEDIA_BUS_FMT_SRGGB10_1X10, (u32[]) { V4L2_PIX_FMT_SRGGB10 }, 1 },
+    { MEDIA_BUS_FMT_SBGGR12_1X12, (u32[]) { V4L2_PIX_FMT_SBGGR12 }, 1 },
+    { MEDIA_BUS_FMT_SGBRG12_1X12, (u32[]) { V4L2_PIX_FMT_SGBRG12 }, 1 },
+    { MEDIA_BUS_FMT_SGRBG12_1X12, (u32[]) { V4L2_PIX_FMT_SGRBG12 }, 1 },
+    { MEDIA_BUS_FMT_SRGGB12_1X12, (u32[]) { V4L2_PIX_FMT_SRGGB12 }, 1 },
+    { MEDIA_BUS_FMT_YUYV8_2X8, (u32[]) { V4L2_PIX_FMT_YUYV }, 1 },
+    { MEDIA_BUS_FMT_YVYU8_2X8, (u32[]) { V4L2_PIX_FMT_YVYU }, 1 },
+    { MEDIA_BUS_FMT_UYVY8_2X8, (u32[]) { V4L2_PIX_FMT_UYVY }, 1 },
+    { MEDIA_BUS_FMT_VYUY8_2X8, (u32[]) { V4L2_PIX_FMT_VYUY }, 1 },
+    { MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE, (u32[]) { V4L2_PIX_FMT_RGB555 }, 1 },
+    { MEDIA_BUS_FMT_UYVY8_2X8, yuv_pixelformats,
+ARRAY_SIZE(yuv_pixelformats) },
+    { MEDIA_BUS_FMT_VYUY8_2X8, yuv_pixelformats,
+ARRAY_SIZE(yuv_pixelformats) },
+    { MEDIA_BUS_FMT_YUYV8_2X8, yuv_pixelformats,
+ARRAY_SIZE(yuv_pixelformats) },
+    { MEDIA_BUS_FMT_YVYU8_2X8, yuv_pixelformats,
+ARRAY_SIZE(yuv_pixelformats) },
+    { MEDIA_BUS_FMT_RGB565_2X8_LE, (u32[]) { V4L2_PIX_FMT_RGB565 }, 1 },
+    { MEDIA_BUS_FMT_RGB565_2X8_BE, (u32[]) { V4L2_PIX_FMT_RGB565X }, 1 },
+    { MEDIA_BUS_FMT_JPEG_1X8, (u32[]) { V4L2_PIX_FMT_JPEG }, 1 },
+};
+
+
 /* TODO add 10&12 bit YUV, RGB support */
-bool sun6i_csi_is_format_supported(struct sun6i_csi *csi,
-				   u32 pixformat, u32 mbus_code,
-				   struct v4l2_fwnode_endpoint* vep)
+bool sun6i_csi_get_pixelformats(u32 mbus_code,
+                struct v4l2_fwnode_endpoint* vep,
+                u32 **pixelformats,
+                u32 *pixelformats_size)
 {
-	struct sun6i_csi_dev *sdev = sun6i_csi_to_dev(csi);
+    u32 i;
 
 	/*
 	 * Some video receivers have the ability to be compatible with
@@ -59,109 +114,26 @@
 	 * Identify the media bus format from device tree.
 	 */
 	if ((vep->bus_type == V4L2_MBUS_PARALLEL
-	     || vep->bus_type == V4L2_MBUS_BT656)
-	     && vep->bus.parallel.bus_width == 16) {
-		switch (pixformat) {
-		case V4L2_PIX_FMT_HM12:
-		case V4L2_PIX_FMT_NV12:
-		case V4L2_PIX_FMT_NV21:
-		case V4L2_PIX_FMT_NV16:
-		case V4L2_PIX_FMT_NV61:
-		case V4L2_PIX_FMT_YUV420:
-		case V4L2_PIX_FMT_YVU420:
-		case V4L2_PIX_FMT_YUV422P:
-			switch (mbus_code) {
-			case MEDIA_BUS_FMT_UYVY8_1X16:
-			case MEDIA_BUS_FMT_VYUY8_1X16:
-			case MEDIA_BUS_FMT_YUYV8_1X16:
-			case MEDIA_BUS_FMT_YVYU8_1X16:
+        || vep->bus_type == V4L2_MBUS_BT656)
+        && vep->bus.parallel.bus_width == 16) {
+        for (i = 0; i < ARRAY_SIZE(wide_bus_modes); ++i) {
+            if (modes[i].mbus_code == mbus_code) {
+                *pixelformats = modes[i].pixelformats;
+                *pixelformats_size = modes[i].pixelformats_size;
 				return true;
-			default:
-				dev_dbg(sdev->dev, "Unsupported mbus code: 0x%x\n",
-					mbus_code);
-				break;
 			}
-			break;
-		default:
-			dev_dbg(sdev->dev, "Unsupported pixformat: 0x%x\n",
-				pixformat);
-			break;
 		}
 		return false;
 	}
 
-	switch (pixformat) {
-	case V4L2_PIX_FMT_SBGGR8:
-		return (mbus_code == MEDIA_BUS_FMT_SBGGR8_1X8);
-	case V4L2_PIX_FMT_SGBRG8:
-		return (mbus_code == MEDIA_BUS_FMT_SGBRG8_1X8);
-	case V4L2_PIX_FMT_SGRBG8:
-		return (mbus_code == MEDIA_BUS_FMT_SGRBG8_1X8);
-	case V4L2_PIX_FMT_SRGGB8:
-		return (mbus_code == MEDIA_BUS_FMT_SRGGB8_1X8);
-	case V4L2_PIX_FMT_SBGGR10:
-		return (mbus_code == MEDIA_BUS_FMT_SBGGR10_1X10);
-	case V4L2_PIX_FMT_SGBRG10:
-		return (mbus_code == MEDIA_BUS_FMT_SGBRG10_1X10);
-	case V4L2_PIX_FMT_SGRBG10:
-		return (mbus_code == MEDIA_BUS_FMT_SGRBG10_1X10);
-	case V4L2_PIX_FMT_SRGGB10:
-		return (mbus_code == MEDIA_BUS_FMT_SRGGB10_1X10);
-	case V4L2_PIX_FMT_SBGGR12:
-		return (mbus_code == MEDIA_BUS_FMT_SBGGR12_1X12);
-	case V4L2_PIX_FMT_SGBRG12:
-		return (mbus_code == MEDIA_BUS_FMT_SGBRG12_1X12);
-	case V4L2_PIX_FMT_SGRBG12:
-		return (mbus_code == MEDIA_BUS_FMT_SGRBG12_1X12);
-	case V4L2_PIX_FMT_SRGGB12:
-		return (mbus_code == MEDIA_BUS_FMT_SRGGB12_1X12);
-
-	case V4L2_PIX_FMT_YUYV:
-		return (mbus_code == MEDIA_BUS_FMT_YUYV8_2X8);
-	case V4L2_PIX_FMT_YVYU:
-		return (mbus_code == MEDIA_BUS_FMT_YVYU8_2X8);
-	case V4L2_PIX_FMT_UYVY:
-		return (mbus_code == MEDIA_BUS_FMT_UYVY8_2X8);
-	case V4L2_PIX_FMT_VYUY:
-		return (mbus_code == MEDIA_BUS_FMT_VYUY8_2X8);
-
-	case V4L2_PIX_FMT_RGB555:
-		return mbus_code == MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE;
-
-	case V4L2_PIX_FMT_HM12:
-	case V4L2_PIX_FMT_NV12:
-	case V4L2_PIX_FMT_NV21:
-	case V4L2_PIX_FMT_NV16:
-	case V4L2_PIX_FMT_NV61:
-	case V4L2_PIX_FMT_YUV420:
-	case V4L2_PIX_FMT_YVU420:
-	case V4L2_PIX_FMT_YUV422P:
-		switch (mbus_code) {
-		case MEDIA_BUS_FMT_UYVY8_2X8:
-		case MEDIA_BUS_FMT_VYUY8_2X8:
-		case MEDIA_BUS_FMT_YUYV8_2X8:
-		case MEDIA_BUS_FMT_YVYU8_2X8:
+
+    for (i = 0; i < ARRAY_SIZE(modes); ++i) {
+		if (modes[i].mbus_code == mbus_code) {
+            *pixelformats = modes[i].pixelformats;
+            *pixelformats_size = modes[i].pixelformats_size;
 			return true;
-		default:
-			dev_dbg(sdev->dev, "Unsupported mbus code: 0x%x\n",
-				mbus_code);
-			break;
 		}
-		break;
-
-	case V4L2_PIX_FMT_RGB565:
-		return (mbus_code == MEDIA_BUS_FMT_RGB565_2X8_LE);
-	case V4L2_PIX_FMT_RGB565X:
-		return (mbus_code == MEDIA_BUS_FMT_RGB565_2X8_BE);
-
-	case V4L2_PIX_FMT_JPEG:
-		return (mbus_code == MEDIA_BUS_FMT_JPEG_1X8);
-
-	default:
-		dev_dbg(sdev->dev, "Unsupported pixformat: 0x%x\n", pixformat);
-		break;
 	}
-
 	return false;
 }
 
--- a/drivers/media/platform/sunxi/sun6i-csi/sun6i_video.c	2022-06-29 21:05:59.960623279 +0300
+++ b/drivers/media/platform/sunxi/sun6i-csi/sun6i_video.c	2022-06-29 21:37:31.224855952 +0300
@@ -31,44 +31,15 @@
 	bool				queued_to_csi;
 };
 
-static const u32 supported_pixformats[] = {
-	V4L2_PIX_FMT_SBGGR8,
-	V4L2_PIX_FMT_SGBRG8,
-	V4L2_PIX_FMT_SGRBG8,
-	V4L2_PIX_FMT_SRGGB8,
-	V4L2_PIX_FMT_SBGGR10,
-	V4L2_PIX_FMT_SGBRG10,
-	V4L2_PIX_FMT_SGRBG10,
-	V4L2_PIX_FMT_SRGGB10,
-	V4L2_PIX_FMT_SBGGR12,
-	V4L2_PIX_FMT_SGBRG12,
-	V4L2_PIX_FMT_SGRBG12,
-	V4L2_PIX_FMT_SRGGB12,
-	V4L2_PIX_FMT_YUYV,
-	V4L2_PIX_FMT_YVYU,
-	V4L2_PIX_FMT_UYVY,
-	V4L2_PIX_FMT_VYUY,
-	V4L2_PIX_FMT_RGB565,
-	V4L2_PIX_FMT_RGB555,
-	V4L2_PIX_FMT_HM12,
-	V4L2_PIX_FMT_NV12,
-	V4L2_PIX_FMT_NV21,
-	V4L2_PIX_FMT_YUV420,
-	V4L2_PIX_FMT_YVU420,
-	V4L2_PIX_FMT_NV16,
-	V4L2_PIX_FMT_NV61,
-	V4L2_PIX_FMT_YUV422P,
-	V4L2_PIX_FMT_RGB565,
-	V4L2_PIX_FMT_RGB565X,
-	V4L2_PIX_FMT_JPEG,
-};
-
-static bool is_pixformat_valid(unsigned int pixformat)
+static bool is_pixformat_valid(u32 pixformat,
+                   u32 *pixformats,
+                   u32 pixelformats_size)
 {
-	unsigned int i;
+    u32 i;
+
 
-	for (i = 0; i < ARRAY_SIZE(supported_pixformats); i++)
-		if (supported_pixformats[i] == pixformat)
+    for (i = 0; i < pixelformats_size; i++)
+        if (pixformats[i] == pixformat)
 			return true;
 
 	return false;
@@ -331,123 +302,65 @@
 	return 0;
 }
 
+static int sun6i_get_available_formats(struct sun6i_video *video,
+                       u32 **pixelformats,
+                       u32 *pixelformats_size,
+                       struct v4l2_subdev_format *subdev_format)
+{
+    struct v4l2_subdev *sd;
+    u32 sd_pad;
+    struct sun6i_csi_async_subdev* casd;
+    struct v4l2_subdev_format source_fmt = {};
+    int ret;
+
+    sd = sun6i_video_remote_subdev(video, &sd_pad);
+    if (!sd)
+        return -EPIPE;
+
+    casd = container_of(sd->asd, struct sun6i_csi_async_subdev, asd);
+
+	// Get format from subdev
+    source_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	source_fmt.pad = sd_pad;
+
+    ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &source_fmt);
+    if (ret < 0)
+        return ret;
+
+    // Get pixelformats compatible with the subdev bus format
+    if (!sun6i_csi_get_pixelformats(source_fmt.format.code,
+                    &casd->vep,
+                    pixelformats,
+                    pixelformats_size)) {
+        return -EPIPE;
+    }
+
+    if (subdev_format)
+        *subdev_format = source_fmt;
+
+	return 0;
+}
+
+
 static int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,
-				   struct v4l2_fmtdesc *f)
+                   struct v4l2_fmtdesc *f)
 {
+	struct sun6i_video *video = video_drvdata(file);
 	u32 index = f->index;
+	u32 *pixelformats, pixelformats_size;
+    int ret;
 
-	if (index >= ARRAY_SIZE(supported_pixformats))
-		return -EINVAL;
-
+    ret = sun6i_get_available_formats(video,
+                      &pixelformats,
+                      &pixelformats_size,
+                      NULL);
+    if (ret < 0)
+        return ret;
 
-	if (f->mbus_code == 0) {
-		f->pixelformat = supported_pixformats[index];
-		return 0;
-	}
+    if (index >= pixelformats_size)
+        return -EINVAL;
 
-	if (index == 0) {
-		switch (f->mbus_code) {
-		case MEDIA_BUS_FMT_SBGGR8_1X8:
-			f->pixelformat = V4L2_PIX_FMT_SBGGR8;
-			return 0;
-		case MEDIA_BUS_FMT_SGBRG8_1X8:
-			f->pixelformat = V4L2_PIX_FMT_SGBRG8;
-			return 0;
-		case MEDIA_BUS_FMT_SGRBG8_1X8:
-			f->pixelformat = V4L2_PIX_FMT_SGRBG8;
-			return 0;
-		case MEDIA_BUS_FMT_SRGGB8_1X8:
-			f->pixelformat = V4L2_PIX_FMT_SRGGB8;
-			return 0;
-		case MEDIA_BUS_FMT_SBGGR10_1X10:
-			f->pixelformat = V4L2_PIX_FMT_SBGGR10;
-			return 0;
-		case MEDIA_BUS_FMT_SGBRG10_1X10:
-			f->pixelformat = V4L2_PIX_FMT_SGBRG10;
-			return 0;
-		case MEDIA_BUS_FMT_SGRBG10_1X10:
-			f->pixelformat = V4L2_PIX_FMT_SGRBG10;
-			return 0;
-		case MEDIA_BUS_FMT_SRGGB10_1X10:
-			f->pixelformat = V4L2_PIX_FMT_SRGGB10;
-			return 0;
-		case MEDIA_BUS_FMT_SBGGR12_1X12:
-			f->pixelformat = V4L2_PIX_FMT_SBGGR12;
-			return 0;
-		case MEDIA_BUS_FMT_SGBRG12_1X12:
-			f->pixelformat = V4L2_PIX_FMT_SGBRG12;
-			return 0;
-		case MEDIA_BUS_FMT_SGRBG12_1X12:
-			f->pixelformat = V4L2_PIX_FMT_SGRBG12;
-			return 0;
-		case MEDIA_BUS_FMT_SRGGB12_1X12:
-			f->pixelformat = V4L2_PIX_FMT_SRGGB12;
-			return 0;
-		case MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE:
-			f->pixelformat = V4L2_PIX_FMT_RGB555;
-			return 0;
-		case MEDIA_BUS_FMT_RGB565_2X8_BE:
-			f->pixelformat = V4L2_PIX_FMT_RGB565X;
-			return 0;
-		case MEDIA_BUS_FMT_RGB565_2X8_LE:
-			f->pixelformat = V4L2_PIX_FMT_RGB565;
-			return 0;
-		case MEDIA_BUS_FMT_YUYV8_2X8:
-			f->pixelformat = V4L2_PIX_FMT_YUYV;
-			return 0;
-		case MEDIA_BUS_FMT_YVYU8_2X8:
-			f->pixelformat = V4L2_PIX_FMT_YVYU;
-			return 0;
-		case MEDIA_BUS_FMT_UYVY8_2X8:
-			f->pixelformat = V4L2_PIX_FMT_UYVY;
-			return 0;
-		case MEDIA_BUS_FMT_VYUY8_2X8:
-			f->pixelformat = V4L2_PIX_FMT_VYUY;
-			return 0;
-		case MEDIA_BUS_FMT_JPEG_1X8:
-			f->pixelformat = V4L2_PIX_FMT_JPEG;
-			return 0;
-		default:
-			return -EINVAL;
-		}
-	} else {
-		switch (f->mbus_code) {
-		case MEDIA_BUS_FMT_UYVY8_2X8:
-		case MEDIA_BUS_FMT_VYUY8_2X8:
-		case MEDIA_BUS_FMT_YUYV8_2X8:
-		case MEDIA_BUS_FMT_YVYU8_2X8:
-			switch (index) {
-			case 1:
-				f->pixelformat = V4L2_PIX_FMT_HM12;
-				return 0;
-			case 2:
-				f->pixelformat = V4L2_PIX_FMT_NV12;
-				return 0;
-			case 3:
-				f->pixelformat = V4L2_PIX_FMT_NV21;
-				return 0;
-			case 4:
-				f->pixelformat = V4L2_PIX_FMT_NV16;
-				return 0;
-			case 5:
-				f->pixelformat = V4L2_PIX_FMT_NV61;
-				return 0;
-			case 6:
-				f->pixelformat = V4L2_PIX_FMT_YUV420;
-				return 0;
-			case 7:
-				f->pixelformat = V4L2_PIX_FMT_YVU420;
-				return 0;
-			case 8:
-				f->pixelformat = V4L2_PIX_FMT_YUV422P;
-				return 0;
-			default:
-				return -EINVAL;
-			}
-		default:
-			return -EINVAL;
-		}
-	}
+    f->pixelformat = pixelformats[index];
 
 	return 0;
 }
@@ -463,14 +376,27 @@
 }
 
 static int sun6i_video_try_fmt(struct sun6i_video *video,
-			       struct v4l2_format *f)
+                   struct v4l2_format *f,
+                   struct v4l2_subdev_format *subdev_format)
 {
-	struct v4l2_pix_format *pixfmt = &f->fmt.pix;
-	int bpp;
-	u32 bpl_packed;
-
-	if (!is_pixformat_valid(pixfmt->pixelformat))
-		pixfmt->pixelformat = supported_pixformats[0];
+     struct v4l2_pix_format *pixfmt = &f->fmt.pix;
+     int bpp;
+     u32 bpl_packed;
+    int ret;
+    u32 *pixelformats, pixelformats_size;
+
+    ret = sun6i_get_available_formats(video,
+                      &pixelformats,
+                      &pixelformats_size,
+                      subdev_format);
+    if (ret)
+        return ret;
+
+    if (!is_pixformat_valid(pixfmt->pixelformat,
+                pixelformats,
+                pixelformats_size)) {
+        pixfmt->pixelformat = pixelformats[0];
+    }
 
 	v4l_bound_align_image(&pixfmt->width, MIN_WIDTH, MAX_WIDTH, 1,
 			      &pixfmt->height, MIN_HEIGHT, MAX_WIDTH, 1, 1);
@@ -496,11 +422,28 @@
 	return 0;
 }
 
+static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
+                struct v4l2_format *fmt)
+{
+    struct sun6i_video *video = video_drvdata(file);
+    int ret;
+
+    // Let the try_fmt set the video format to something available before
+    // returning, as the subdev may change it's bus format in-between calls.
+    ret = sun6i_video_try_fmt(video, &video->fmt, NULL);
+    if (ret < 0)
+        return ret;
+
+    *fmt = video->fmt;
+
+    return 0;
+}
+
 static int sun6i_video_set_fmt(struct sun6i_video *video, struct v4l2_format *f)
 {
 	int ret;
 
-	ret = sun6i_video_try_fmt(video, f);
+    ret = sun6i_video_try_fmt(video, f, NULL);
 	if (ret)
 		return ret;
 
@@ -518,6 +461,7 @@
 		return -EBUSY;
 
 	return sun6i_video_set_fmt(video, f);
+
 }
 
 static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
@@ -525,7 +469,8 @@
 {
 	struct sun6i_video *video = video_drvdata(file);
 
-	return sun6i_video_try_fmt(video, f);
+    return sun6i_video_try_fmt(video, f, NULL);
+
 }
 
 static int vidioc_enum_framesizes(struct file *file, void *priv,
@@ -721,10 +666,6 @@
 {
 	struct video_device *vdev = container_of(link->sink->entity,
 						 struct video_device, entity);
-	struct v4l2_subdev *sd =
-			media_entity_to_v4l2_subdev(link->source->entity);
-	struct sun6i_csi_async_subdev* casd =
-			container_of(sd->asd, struct sun6i_csi_async_subdev, asd);
 	struct sun6i_video *video = video_get_drvdata(vdev);
 	struct v4l2_subdev_format source_fmt = {};
 	int ret;
@@ -740,24 +681,10 @@
 	if (!is_media_entity_v4l2_subdev(link->source->entity))
 		return -EINVAL;
 
-	source_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
-	source_fmt.pad = link->source->index;
-
-	ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &source_fmt);
+    ret = sun6i_video_try_fmt(video, &video->fmt, &source_fmt);
 	if (ret < 0)
 		return ret;
 
-	if (!sun6i_csi_is_format_supported(video->csi,
-					   video->fmt.fmt.pix.pixelformat,
-					   source_fmt.format.code,
-					   &casd->vep)) {
-		dev_err(video->csi->dev,
-			"Unsupported pixformat: 0x%x with mbus code: 0x%x!\n",
-			video->fmt.fmt.pix.pixelformat,
-			source_fmt.format.code);
-		return -EPIPE;
-	}
-
 	if (source_fmt.format.width != video->fmt.fmt.pix.width ||
 	    source_fmt.format.height != video->fmt.fmt.pix.height) {
 		dev_err(video->csi->dev,
@@ -813,14 +740,6 @@
 
 	video->sequence = 0;
 
-	/* Setup default format */
-	fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	fmt.fmt.pix.pixelformat = supported_pixformats[0];
-	fmt.fmt.pix.width = 1280;
-	fmt.fmt.pix.height = 720;
-	fmt.fmt.pix.field = V4L2_FIELD_NONE;
-	sun6i_video_set_fmt(video, &fmt);
-
 	/* Initialize videobuf2 queue */
 	vidq->type			= V4L2_BUF_TYPE_VIDEO_CAPTURE;
 	vidq->io_modes			= VB2_MMAP | VB2_DMABUF;
@@ -854,6 +773,19 @@
 		V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_IO_MC;
 	video_set_drvdata(vdev, video);
 
+    /* Setup default format */
+    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_SBGGR8;
+    fmt.fmt.pix.width = 1280;
+    fmt.fmt.pix.height = 720;
+    fmt.fmt.pix.field = V4L2_FIELD_NONE;
+    fmt.fmt.pix.sizeimage = fmt.fmt.pix.width * fmt.fmt.pix.height;
+    fmt.fmt.pix.colorspace = V4L2_COLORSPACE_RAW;
+    fmt.fmt.pix.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+    fmt.fmt.pix.quantization = V4L2_QUANTIZATION_DEFAULT;
+    fmt.fmt.pix.xfer_func = V4L2_XFER_FUNC_DEFAULT;
+    video->fmt = fmt;
+
 	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
 	if (ret < 0) {
 		v4l2_err(&csi->v4l2_dev,
