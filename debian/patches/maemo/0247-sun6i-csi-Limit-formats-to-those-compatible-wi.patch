From 6ba9b23163ad3aac094ad058a2835b2601ee6207 Mon Sep 17 00:00:00 2001
From: Benjamin Schaaf <ben.schaaf@gmail.com>
Date: Mon, 22 Nov 2021 23:38:26 +1100
Subject: [PATCH] media: sun6i-csi: Limit formats to those compatible with
 sub-device

To make format enumeration useful it needs to be limited to the formats
that are valid for the currently linked sub-device.
---
 .../platform/sunxi/sun6i-csi/sun6i_csi.c      | 158 ++++++---------
 .../platform/sunxi/sun6i-csi/sun6i_csi.h      |  23 ++-
 .../platform/sunxi/sun6i-csi/sun6i_video.c    | 180 ++++++++++--------
 3 files changed, 178 insertions(+), 183 deletions(-)

diff --git a/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.c b/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.c
index 44e18419f4cf..3098ff118eb7 100644
--- a/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.c
+++ b/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.c
@@ -46,12 +46,58 @@ static inline struct sun6i_csi_dev *sun6i_csi_to_dev(struct sun6i_csi *csi)
 	return container_of(csi, struct sun6i_csi_dev, csi);
 }
 
+static u32 yuv_pixelformats[] = {
+	V4L2_PIX_FMT_HM12,
+	V4L2_PIX_FMT_NV12,
+	V4L2_PIX_FMT_NV21,
+	V4L2_PIX_FMT_NV16,
+	V4L2_PIX_FMT_NV61,
+	V4L2_PIX_FMT_YUV420,
+	V4L2_PIX_FMT_YVU420,
+	V4L2_PIX_FMT_YUV422P,
+};
+
+static struct sun6i_csi_mode wide_bus_modes[] = {
+	{ MEDIA_BUS_FMT_UYVY8_1X16, yuv_pixelformats, ARRAY_SIZE(yuv_pixelformats) },
+	{ MEDIA_BUS_FMT_VYUY8_1X16, yuv_pixelformats, ARRAY_SIZE(yuv_pixelformats) },
+	{ MEDIA_BUS_FMT_YUYV8_1X16, yuv_pixelformats, ARRAY_SIZE(yuv_pixelformats) },
+	{ MEDIA_BUS_FMT_YVYU8_1X16, yuv_pixelformats, ARRAY_SIZE(yuv_pixelformats) },
+};
+
+static struct sun6i_csi_mode modes[] = {
+	{ MEDIA_BUS_FMT_SBGGR8_1X8, (u32[]) { V4L2_PIX_FMT_SBGGR8 }, 1 },
+	{ MEDIA_BUS_FMT_SGBRG8_1X8, (u32[]) { V4L2_PIX_FMT_SGBRG8 }, 1 },
+	{ MEDIA_BUS_FMT_SGRBG8_1X8, (u32[]) { V4L2_PIX_FMT_SGRBG8 }, 1 },
+	{ MEDIA_BUS_FMT_SRGGB8_1X8, (u32[]) { V4L2_PIX_FMT_SRGGB8 }, 1 },
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, (u32[]) { V4L2_PIX_FMT_SBGGR10 }, 1 },
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, (u32[]) { V4L2_PIX_FMT_SGBRG10 }, 1 },
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, (u32[]) { V4L2_PIX_FMT_SGRBG10 }, 1 },
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, (u32[]) { V4L2_PIX_FMT_SRGGB10 }, 1 },
+	{ MEDIA_BUS_FMT_SBGGR12_1X12, (u32[]) { V4L2_PIX_FMT_SBGGR12 }, 1 },
+	{ MEDIA_BUS_FMT_SGBRG12_1X12, (u32[]) { V4L2_PIX_FMT_SGBRG12 }, 1 },
+	{ MEDIA_BUS_FMT_SGRBG12_1X12, (u32[]) { V4L2_PIX_FMT_SGRBG12 }, 1 },
+	{ MEDIA_BUS_FMT_SRGGB12_1X12, (u32[]) { V4L2_PIX_FMT_SRGGB12 }, 1 },
+	{ MEDIA_BUS_FMT_YUYV8_2X8, (u32[]) { V4L2_PIX_FMT_YUYV }, 1 },
+	{ MEDIA_BUS_FMT_YVYU8_2X8, (u32[]) { V4L2_PIX_FMT_YVYU }, 1 },
+	{ MEDIA_BUS_FMT_UYVY8_2X8, (u32[]) { V4L2_PIX_FMT_UYVY }, 1 },
+	{ MEDIA_BUS_FMT_VYUY8_2X8, (u32[]) { V4L2_PIX_FMT_VYUY }, 1 },
+	{ MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE, (u32[]) { V4L2_PIX_FMT_RGB555 }, 1 },
+	{ MEDIA_BUS_FMT_UYVY8_2X8, yuv_pixelformats, ARRAY_SIZE(yuv_pixelformats) },
+	{ MEDIA_BUS_FMT_VYUY8_2X8, yuv_pixelformats, ARRAY_SIZE(yuv_pixelformats) },
+	{ MEDIA_BUS_FMT_YUYV8_2X8, yuv_pixelformats, ARRAY_SIZE(yuv_pixelformats) },
+	{ MEDIA_BUS_FMT_YVYU8_2X8, yuv_pixelformats, ARRAY_SIZE(yuv_pixelformats) },
+	{ MEDIA_BUS_FMT_RGB565_2X8_LE, (u32[]) { V4L2_PIX_FMT_RGB565 }, 1 },
+	{ MEDIA_BUS_FMT_RGB565_2X8_BE, (u32[]) { V4L2_PIX_FMT_RGB565X }, 1 },
+	{ MEDIA_BUS_FMT_JPEG_1X8, (u32[]) { V4L2_PIX_FMT_JPEG }, 1 },
+};
+
 /* TODO add 10&12 bit YUV, RGB support */
-bool sun6i_csi_is_format_supported(struct sun6i_csi *csi,
-				   u32 pixformat, u32 mbus_code,
-				   struct v4l2_fwnode_endpoint* vep)
+bool sun6i_csi_get_pixelformats(u32 mbus_code,
+				struct v4l2_fwnode_endpoint* vep,
+				u32 **pixelformats,
+				u32 *pixelformats_size)
 {
-	struct sun6i_csi_dev *sdev = sun6i_csi_to_dev(csi);
+	u32 i;
 
 	/*
 	 * Some video receivers have the ability to be compatible with
@@ -59,109 +105,25 @@ bool sun6i_csi_is_format_supported(struct sun6i_csi *csi,
 	 * Identify the media bus format from device tree.
 	 */
 	if ((vep->bus_type == V4L2_MBUS_PARALLEL
-	     || vep->bus_type == V4L2_MBUS_BT656)
-	     && vep->bus.parallel.bus_width == 16) {
-		switch (pixformat) {
-		case V4L2_PIX_FMT_HM12:
-		case V4L2_PIX_FMT_NV12:
-		case V4L2_PIX_FMT_NV21:
-		case V4L2_PIX_FMT_NV16:
-		case V4L2_PIX_FMT_NV61:
-		case V4L2_PIX_FMT_YUV420:
-		case V4L2_PIX_FMT_YVU420:
-		case V4L2_PIX_FMT_YUV422P:
-			switch (mbus_code) {
-			case MEDIA_BUS_FMT_UYVY8_1X16:
-			case MEDIA_BUS_FMT_VYUY8_1X16:
-			case MEDIA_BUS_FMT_YUYV8_1X16:
-			case MEDIA_BUS_FMT_YVYU8_1X16:
+	    || vep->bus_type == V4L2_MBUS_BT656)
+	    && vep->bus.parallel.bus_width == 16) {
+		for (i = 0; i < ARRAY_SIZE(wide_bus_modes); ++i) {
+			if (modes[i].mbus_code == mbus_code) {
+				*pixelformats = modes[i].pixelformats;
+				*pixelformats_size = modes[i].pixelformats_size;
 				return true;
-			default:
-				dev_dbg(sdev->dev, "Unsupported mbus code: 0x%x\n",
-					mbus_code);
-				break;
 			}
-			break;
-		default:
-			dev_dbg(sdev->dev, "Unsupported pixformat: 0x%x\n",
-				pixformat);
-			break;
 		}
 		return false;
 	}
 
-	switch (pixformat) {
-	case V4L2_PIX_FMT_SBGGR8:
-		return (mbus_code == MEDIA_BUS_FMT_SBGGR8_1X8);
-	case V4L2_PIX_FMT_SGBRG8:
-		return (mbus_code == MEDIA_BUS_FMT_SGBRG8_1X8);
-	case V4L2_PIX_FMT_SGRBG8:
-		return (mbus_code == MEDIA_BUS_FMT_SGRBG8_1X8);
-	case V4L2_PIX_FMT_SRGGB8:
-		return (mbus_code == MEDIA_BUS_FMT_SRGGB8_1X8);
-	case V4L2_PIX_FMT_SBGGR10:
-		return (mbus_code == MEDIA_BUS_FMT_SBGGR10_1X10);
-	case V4L2_PIX_FMT_SGBRG10:
-		return (mbus_code == MEDIA_BUS_FMT_SGBRG10_1X10);
-	case V4L2_PIX_FMT_SGRBG10:
-		return (mbus_code == MEDIA_BUS_FMT_SGRBG10_1X10);
-	case V4L2_PIX_FMT_SRGGB10:
-		return (mbus_code == MEDIA_BUS_FMT_SRGGB10_1X10);
-	case V4L2_PIX_FMT_SBGGR12:
-		return (mbus_code == MEDIA_BUS_FMT_SBGGR12_1X12);
-	case V4L2_PIX_FMT_SGBRG12:
-		return (mbus_code == MEDIA_BUS_FMT_SGBRG12_1X12);
-	case V4L2_PIX_FMT_SGRBG12:
-		return (mbus_code == MEDIA_BUS_FMT_SGRBG12_1X12);
-	case V4L2_PIX_FMT_SRGGB12:
-		return (mbus_code == MEDIA_BUS_FMT_SRGGB12_1X12);
-
-	case V4L2_PIX_FMT_YUYV:
-		return (mbus_code == MEDIA_BUS_FMT_YUYV8_2X8);
-	case V4L2_PIX_FMT_YVYU:
-		return (mbus_code == MEDIA_BUS_FMT_YVYU8_2X8);
-	case V4L2_PIX_FMT_UYVY:
-		return (mbus_code == MEDIA_BUS_FMT_UYVY8_2X8);
-	case V4L2_PIX_FMT_VYUY:
-		return (mbus_code == MEDIA_BUS_FMT_VYUY8_2X8);
-
-	case V4L2_PIX_FMT_RGB555:
-		return mbus_code == MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE;
-
-	case V4L2_PIX_FMT_HM12:
-	case V4L2_PIX_FMT_NV12:
-	case V4L2_PIX_FMT_NV21:
-	case V4L2_PIX_FMT_NV16:
-	case V4L2_PIX_FMT_NV61:
-	case V4L2_PIX_FMT_YUV420:
-	case V4L2_PIX_FMT_YVU420:
-	case V4L2_PIX_FMT_YUV422P:
-		switch (mbus_code) {
-		case MEDIA_BUS_FMT_UYVY8_2X8:
-		case MEDIA_BUS_FMT_VYUY8_2X8:
-		case MEDIA_BUS_FMT_YUYV8_2X8:
-		case MEDIA_BUS_FMT_YVYU8_2X8:
+	for (i = 0; i < ARRAY_SIZE(modes); ++i) {
+		if (modes[i].mbus_code == mbus_code) {
+			*pixelformats = modes[i].pixelformats;
+			*pixelformats_size = modes[i].pixelformats_size;
 			return true;
-		default:
-			dev_dbg(sdev->dev, "Unsupported mbus code: 0x%x\n",
-				mbus_code);
-			break;
 		}
-		break;
-
-	case V4L2_PIX_FMT_RGB565:
-		return (mbus_code == MEDIA_BUS_FMT_RGB565_2X8_LE);
-	case V4L2_PIX_FMT_RGB565X:
-		return (mbus_code == MEDIA_BUS_FMT_RGB565_2X8_BE);
-
-	case V4L2_PIX_FMT_JPEG:
-		return (mbus_code == MEDIA_BUS_FMT_JPEG_1X8);
-
-	default:
-		dev_dbg(sdev->dev, "Unsupported pixformat: 0x%x\n", pixformat);
-		break;
 	}
-
 	return false;
 }
 
diff --git a/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.h b/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.h
index 3be680938255..c2bdeb5ec21f 100644
--- a/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.h
+++ b/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.h
@@ -48,16 +48,23 @@ struct sun6i_csi_async_subdev {
 	struct v4l2_fwnode_endpoint	vep;
 };
 
+struct sun6i_csi_mode {
+	u32	mbus_code;
+	u32	*pixelformats;
+	u32	pixelformats_size;
+};
+
 /**
- * sun6i_csi_is_format_supported() - check if the format supported by csi
- * @csi:	pointer to the csi
- * @pixformat:	v4l2 pixel format (V4L2_PIX_FMT_*)
- * @mbus_code:	media bus format code (MEDIA_BUS_FMT_*)
- * @vep:        parsed CSI side bus endpoint configuration
+ * sun6i_csi_get_pixelformats() - get the valid pixel formats for a bus code
+ * @mbus_code:		the bus code
+ * @vep:		parsed CSI side bus endpoint configuration
+ * @pixelformats:	returned list of valid pixel formats
+ * @pixelformats_size:	size of pixelformats
  */
-bool sun6i_csi_is_format_supported(struct sun6i_csi *csi,
-				   u32 pixformat, u32 mbus_code,
-				   struct v4l2_fwnode_endpoint* vep);
+bool sun6i_csi_get_pixelformats(u32 mbus_code,
+				struct v4l2_fwnode_endpoint* vep,
+				u32 **pixelformats,
+				u32 *pixelformats_size);
 
 /**
  * sun6i_csi_set_power() - power on/off the csi
diff --git a/drivers/media/platform/sunxi/sun6i-csi/sun6i_video.c b/drivers/media/platform/sunxi/sun6i-csi/sun6i_video.c
index 23fb296e1d0c..8b3c9f944106 100644
--- a/drivers/media/platform/sunxi/sun6i-csi/sun6i_video.c
+++ b/drivers/media/platform/sunxi/sun6i-csi/sun6i_video.c
@@ -31,44 +31,14 @@ struct sun6i_csi_buffer {
 	bool				queued_to_csi;
 };
 
-static const u32 supported_pixformats[] = {
-	V4L2_PIX_FMT_SBGGR8,
-	V4L2_PIX_FMT_SGBRG8,
-	V4L2_PIX_FMT_SGRBG8,
-	V4L2_PIX_FMT_SRGGB8,
-	V4L2_PIX_FMT_SBGGR10,
-	V4L2_PIX_FMT_SGBRG10,
-	V4L2_PIX_FMT_SGRBG10,
-	V4L2_PIX_FMT_SRGGB10,
-	V4L2_PIX_FMT_SBGGR12,
-	V4L2_PIX_FMT_SGBRG12,
-	V4L2_PIX_FMT_SGRBG12,
-	V4L2_PIX_FMT_SRGGB12,
-	V4L2_PIX_FMT_YUYV,
-	V4L2_PIX_FMT_YVYU,
-	V4L2_PIX_FMT_UYVY,
-	V4L2_PIX_FMT_VYUY,
-	V4L2_PIX_FMT_RGB565,
-	V4L2_PIX_FMT_RGB555,
-	V4L2_PIX_FMT_HM12,
-	V4L2_PIX_FMT_NV12,
-	V4L2_PIX_FMT_NV21,
-	V4L2_PIX_FMT_YUV420,
-	V4L2_PIX_FMT_YVU420,
-	V4L2_PIX_FMT_NV16,
-	V4L2_PIX_FMT_NV61,
-	V4L2_PIX_FMT_YUV422P,
-	V4L2_PIX_FMT_RGB565,
-	V4L2_PIX_FMT_RGB565X,
-	V4L2_PIX_FMT_JPEG,
-};
-
-static bool is_pixformat_valid(unsigned int pixformat)
+static bool is_pixformat_valid(u32 pixformat,
+			       u32 *pixformats,
+			       u32 pixelformats_size)
 {
-	unsigned int i;
+	u32 i;
 
-	for (i = 0; i < ARRAY_SIZE(supported_pixformats); i++)
-		if (supported_pixformats[i] == pixformat)
+	for (i = 0; i < pixelformats_size; i++)
+		if (pixformats[i] == pixformat)
 			return true;
 
 	return false;
@@ -331,38 +301,90 @@ static int vidioc_querycap(struct file *file, void *priv,
 	return 0;
 }
 
-static int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,
-				   struct v4l2_fmtdesc *f)
+static int sun6i_get_available_formats(struct sun6i_video *video,
+				       u32 **pixelformats,
+				       u32 *pixelformats_size,
+				       struct v4l2_subdev_format *subdev_format)
 {
-	u32 index = f->index;
+	struct v4l2_subdev *sd;
+	u32 sd_pad;
+	struct sun6i_csi_async_subdev* casd;
+	struct v4l2_subdev_format source_fmt = {};
+	int ret;
 
-	if (index >= ARRAY_SIZE(supported_pixformats))
-		return -EINVAL;
+	sd = sun6i_video_remote_subdev(video, &sd_pad);
+	if (!sd)
+		return -EPIPE;
+
+	casd = container_of(sd->asd, struct sun6i_csi_async_subdev, asd);
 
-	f->pixelformat = supported_pixformats[index];
+	// Get format from subdev
+	source_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	source_fmt.pad = sd_pad;
+
+	ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &source_fmt);
+	if (ret < 0)
+		return ret;
+
+	// Get pixelformats compatible with the subdev bus format
+	if (!sun6i_csi_get_pixelformats(source_fmt.format.code,
+					&casd->vep,
+					pixelformats,
+					pixelformats_size)) {
+		return -EPIPE;
+	}
+
+	if (subdev_format)
+		*subdev_format = source_fmt;
 
 	return 0;
 }
 
-static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
-				struct v4l2_format *fmt)
+static int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,
+				   struct v4l2_fmtdesc *f)
 {
 	struct sun6i_video *video = video_drvdata(file);
+	u32 index = f->index;
+	u32 *pixelformats, pixelformats_size;
+	int ret;
 
-	*fmt = video->fmt;
+	ret = sun6i_get_available_formats(video,
+					  &pixelformats,
+					  &pixelformats_size,
+					  NULL);
+	if (ret < 0)
+		return ret;
+
+	if (index >= pixelformats_size)
+		return -EINVAL;
+
+	f->pixelformat = pixelformats[index];
 
 	return 0;
 }
 
 static int sun6i_video_try_fmt(struct sun6i_video *video,
-			       struct v4l2_format *f)
+			       struct v4l2_format *f,
+			       struct v4l2_subdev_format *subdev_format)
 {
 	struct v4l2_pix_format *pixfmt = &f->fmt.pix;
 	int bpp;
 	u32 bpl_packed;
+	int ret;
+	u32 *pixelformats, pixelformats_size;
+
+	ret = sun6i_get_available_formats(video,
+					  &pixelformats,
+					  &pixelformats_size,
+					  subdev_format);
+	if (ret)
+		return ret;
 
-	if (!is_pixformat_valid(pixfmt->pixelformat))
-		pixfmt->pixelformat = supported_pixformats[0];
+	if (!is_pixformat_valid(pixfmt->pixelformat,
+				pixelformats,
+				pixelformats_size)) {
+		pixfmt->pixelformat = pixelformats[0];
+	}
 
 	v4l_bound_align_image(&pixfmt->width, MIN_WIDTH, MAX_WIDTH, 1,
 			      &pixfmt->height, MIN_HEIGHT, MAX_WIDTH, 1, 1);
@@ -388,11 +410,28 @@ static int sun6i_video_try_fmt(struct sun6i_video *video,
 	return 0;
 }
 
+static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
+				struct v4l2_format *fmt)
+{
+	struct sun6i_video *video = video_drvdata(file);
+	int ret;
+
+	// Let the try_fmt set the video format to something available before
+	// returning, as the subdev may change it's bus format in-between calls.
+	ret = sun6i_video_try_fmt(video, &video->fmt, NULL);
+	if (ret < 0)
+		return ret;
+
+	*fmt = video->fmt;
+
+	return 0;
+}
+
 static int sun6i_video_set_fmt(struct sun6i_video *video, struct v4l2_format *f)
 {
 	int ret;
 
-	ret = sun6i_video_try_fmt(video, f);
+	ret = sun6i_video_try_fmt(video, f, NULL);
 	if (ret)
 		return ret;
 
@@ -417,7 +456,7 @@ static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
 {
 	struct sun6i_video *video = video_drvdata(file);
 
-	return sun6i_video_try_fmt(video, f);
+	return sun6i_video_try_fmt(video, f, NULL);
 }
 
 static int vidioc_enum_framesizes(struct file *file, void *priv,
@@ -613,10 +652,6 @@ static int sun6i_video_link_validate(struct media_link *link)
 {
 	struct video_device *vdev = container_of(link->sink->entity,
 						 struct video_device, entity);
-	struct v4l2_subdev *sd =
-			media_entity_to_v4l2_subdev(link->source->entity);
-	struct sun6i_csi_async_subdev* casd =
-			container_of(sd->asd, struct sun6i_csi_async_subdev, asd);
 	struct sun6i_video *video = video_get_drvdata(vdev);
 	struct v4l2_subdev_format source_fmt = {};
 	int ret;
@@ -632,24 +667,10 @@ static int sun6i_video_link_validate(struct media_link *link)
 	if (!is_media_entity_v4l2_subdev(link->source->entity))
 		return -EINVAL;
 
-	source_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
-	source_fmt.pad = link->source->index;
-
-	ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &source_fmt);
+	ret = sun6i_video_try_fmt(video, &video->fmt, &source_fmt);
 	if (ret < 0)
 		return ret;
 
-	if (!sun6i_csi_is_format_supported(video->csi,
-					   video->fmt.fmt.pix.pixelformat,
-					   source_fmt.format.code,
-					   &casd->vep)) {
-		dev_err(video->csi->dev,
-			"Unsupported pixformat: 0x%x with mbus code: 0x%x!\n",
-			video->fmt.fmt.pix.pixelformat,
-			source_fmt.format.code);
-		return -EPIPE;
-	}
-
 	if (source_fmt.format.width != video->fmt.fmt.pix.width ||
 	    source_fmt.format.height != video->fmt.fmt.pix.height) {
 		dev_err(video->csi->dev,
@@ -705,14 +726,6 @@ int sun6i_video_init(struct sun6i_video *video, struct sun6i_csi *csi,
 
 	video->sequence = 0;
 
-	/* Setup default format */
-	fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	fmt.fmt.pix.pixelformat = supported_pixformats[0];
-	fmt.fmt.pix.width = 1280;
-	fmt.fmt.pix.height = 720;
-	fmt.fmt.pix.field = V4L2_FIELD_NONE;
-	sun6i_video_set_fmt(video, &fmt);
-
 	/* Initialize videobuf2 queue */
 	vidq->type			= V4L2_BUF_TYPE_VIDEO_CAPTURE;
 	vidq->io_modes			= VB2_MMAP | VB2_DMABUF;
@@ -745,6 +758,19 @@ int sun6i_video_init(struct sun6i_video *video, struct sun6i_csi *csi,
 	vdev->device_caps	= V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_IO_MC;
 	video_set_drvdata(vdev, video);
 
+	/* Setup default format */
+	fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_SBGGR8;
+	fmt.fmt.pix.width = 1280;
+	fmt.fmt.pix.height = 720;
+	fmt.fmt.pix.field = V4L2_FIELD_NONE;
+	fmt.fmt.pix.sizeimage = fmt.fmt.pix.width * fmt.fmt.pix.height;
+	fmt.fmt.pix.colorspace = V4L2_COLORSPACE_RAW;
+	fmt.fmt.pix.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	fmt.fmt.pix.quantization = V4L2_QUANTIZATION_DEFAULT;
+	fmt.fmt.pix.xfer_func = V4L2_XFER_FUNC_DEFAULT;
+	video->fmt = fmt;
+
 	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
 	if (ret < 0) {
 		v4l2_err(&csi->v4l2_dev,
-- 
2.25.1

