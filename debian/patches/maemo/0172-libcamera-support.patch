--- a/drivers/media/i2c/ov5640.c	2023-01-13 15:13:50.992326452 +0300
+++ b/drivers/media/i2c/ov5640.c	2023-01-14 19:49:50.542950628 +0300
@@ -1238,7 +1238,6 @@
 		return ret;
 	}
 
-	pm_runtime_mark_last_busy(&sensor->i2c_client->dev);
 	return 0;
 }
 
@@ -1306,7 +1305,6 @@
 	}
 
 	*val = buf[0];
-	pm_runtime_mark_last_busy(&sensor->i2c_client->dev);
 	return 0;
 }
 
@@ -2962,20 +2960,20 @@
 
 static int ov5640_try_frame_interval(struct ov5640_dev *sensor,
 				     struct v4l2_fract *fi,
-				     u32 width, u32 height)
+				     const struct ov5640_mode_info *mode_info)
 {
-	const struct ov5640_mode_info *mode;
-	enum ov5640_frame_rate rate = OV5640_2_FPS;
+	const struct ov5640_mode_info *mode = mode_info;
+	enum ov5640_frame_rate rate = OV5640_15_FPS;
 	int minfps, maxfps, best_fps, fps;
 	int i;
 
-	minfps = ov5640_framerates[OV5640_2_FPS];
-	maxfps = ov5640_framerates[OV5640_60_FPS];
+	minfps = ov5640_framerates[OV5640_15_FPS];
+	maxfps = ov5640_framerates[mode->max_fps];
 
 	if (fi->numerator == 0) {
 		fi->denominator = maxfps;
 		fi->numerator = 1;
-		rate = OV5640_60_FPS;
+		rate = mode->max_fps;
 		goto find_mode;
 	}
 
@@ -2996,7 +2994,7 @@
 	fi->denominator = best_fps;
 
 find_mode:
-	mode = ov5640_find_mode(sensor, width, height, false);
+	mode = ov5640_find_mode(sensor, mode->width, mode->height, false);
 	return mode ? rate : -EINVAL;
 }
 
@@ -3617,7 +3615,6 @@
 		break;
 	}
 
-	pm_runtime_mark_last_busy(&sensor->i2c_client->dev);
 	pm_runtime_put_autosuspend(&sensor->i2c_client->dev);
 
 	return 0;
@@ -3705,7 +3702,6 @@
 		break;
 	}
 
-	pm_runtime_mark_last_busy(&sensor->i2c_client->dev);
 	pm_runtime_put_autosuspend(&sensor->i2c_client->dev);
 
 	return ret;
@@ -3773,7 +3769,7 @@
 	/* Auto/manual gain */
 	ctrls->auto_gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_AUTOGAIN,
 					     0, 1, 1, 1);
-	ctrls->gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_GAIN,
+	ctrls->gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_ANALOGUE_GAIN,
 					0, 1023, 1, 0);
 
 	/* Autofocus */
@@ -3884,6 +3880,7 @@
 	struct v4l2_subdev_frame_interval_enum *fie)
 {
 	struct ov5640_dev *sensor = to_ov5640_dev(sd);
+	const struct ov5640_mode_info *mode;
 	struct v4l2_fract tpf;
 	int ret;
 
@@ -3892,11 +3889,14 @@
 	if (fie->index >= OV5640_NUM_FRAMERATES)
 		return -EINVAL;
 
+	mode = ov5640_find_mode(sensor, fie->width, fie->height, false);
+	if (!mode)
+		return -EINVAL;
+
 	tpf.numerator = 1;
 	tpf.denominator = ov5640_framerates[fie->index];
 
-	ret = ov5640_try_frame_interval(sensor, &tpf,
-					fie->width, fie->height);
+	ret = ov5640_try_frame_interval(sensor, &tpf, mode);
 	if (ret < 0)
 		return -EINVAL;
 
@@ -3935,9 +3935,7 @@
 
 	mode = sensor->current_mode;
 
-	frame_rate = ov5640_try_frame_interval(sensor, &fi->interval,
-					       mode->width,
-					       mode->height);
+	frame_rate = ov5640_try_frame_interval(sensor, &fi->interval, mode);
 	if (frame_rate < 0) {
 		/* Always return a valid frame interval value */
 		fi->interval = sensor->frame_interval;
@@ -4038,10 +4036,8 @@
 out:
 	mutex_unlock(&sensor->lock);
 
-	if (!enable || ret) {
-		pm_runtime_mark_last_busy(&sensor->i2c_client->dev);
+	if (!enable || ret)
 		pm_runtime_put_autosuspend(&sensor->i2c_client->dev);
-	}
 
 	return ret;
 }
@@ -4191,8 +4187,10 @@
 		return ret;
 
 	ret = ov5640_get_regulators(sensor);
-	if (ret)
+	if (ret) {
+		dev_err_probe(dev, ret, "Failed to get regulators\n");
 		goto entity_cleanup;
+	}
 
 	mutex_init(&sensor->lock);
 
@@ -4200,16 +4198,23 @@
 	if (ret)
 		goto entity_cleanup;
 
+	ret = ov5640_sensor_resume(dev);
+	if (ret) {
+		dev_err(dev, "failed to power on\n");
+		goto entity_cleanup;
+	}
+
 	pm_runtime_get_noresume(dev);
 	pm_runtime_enable(dev);
 
 	ret = v4l2_async_register_subdev_sensor(&sensor->sd);
-	if (ret)
+	if (ret) {
+		dev_err_probe(dev, ret, "Failed to register sensor\n");
 		goto err_pm_runtime;
+	}
 
 	pm_runtime_set_autosuspend_delay(dev, 1000);
 	pm_runtime_use_autosuspend(dev);
-	pm_runtime_mark_last_busy(dev);
 	pm_runtime_put_autosuspend(dev);
 
 	return 0;
--- a/drivers/media/platform/sunxi/sun6i-csi/sun6i_video.h	2023-01-13 16:13:56.221514336 +0300
+++ b/drivers/media/platform/sunxi/sun6i-csi/sun6i_video.h	2023-01-13 16:18:06.921182216 +0300
@@ -11,25 +11,28 @@
 #include <media/v4l2-dev.h>
 #include <media/videobuf2-core.h>
 
-struct sun6i_csi_device;
+struct sun6i_csi;
 
 struct sun6i_video {
-	struct video_device		video_dev;
-	struct vb2_queue		queue;
-	struct mutex			lock; /* Queue lock. */
+	struct video_device		vdev;
 	struct media_pad		pad;
+	struct sun6i_csi		*csi;
 
+	struct mutex			lock;
+
+	struct vb2_queue		vb2_vidq;
+	spinlock_t			dma_queue_lock;
 	struct list_head		dma_queue;
-	spinlock_t			dma_queue_lock; /* DMA queue lock. */
 
-	struct v4l2_format		format;
-	u32				mbus_code;
 	unsigned int			sequence;
+	struct v4l2_format		fmt;
+	u32				mbus_code;
 };
 
-int sun6i_video_setup(struct sun6i_csi_device *csi_dev);
-void sun6i_video_cleanup(struct sun6i_csi_device *csi_dev);
+int sun6i_video_init(struct sun6i_video *video, struct sun6i_csi *csi,
+		     const char *name);
+void sun6i_video_cleanup(struct sun6i_video *video);
 
-void sun6i_video_frame_done(struct sun6i_csi_device *csi_dev);
+void sun6i_video_frame_done(struct sun6i_video *video);
 
 #endif /* __SUN6I_VIDEO_H__ */
--- a/drivers/media/platform/sunxi/sun6i-csi/sun6i_video.c	2023-01-13 15:18:11.463616211 +0300
+++ b/drivers/media/platform/sunxi/sun6i-csi/sun6i_video.c	2023-01-13 17:51:19.500924369 +0300
@@ -23,7 +23,26 @@
 #define MAX_WIDTH	(4800)
 #define MAX_HEIGHT	(4800)
 
-/* Helpers */
+struct sun6i_csi_buffer {
+	struct vb2_v4l2_buffer		vb;
+	struct list_head		list;
+
+	dma_addr_t			dma_addr;
+	bool				queued_to_csi;
+};
+
+static bool is_pixformat_valid(u32 pixformat,
+			       u32 *pixformats,
+			       u32 pixelformats_size)
+{
+	u32 i;
+
+	for (i = 0; i < pixelformats_size; i++)
+		if (pixformats[i] == pixformat)
+			return true;
+
+	return false;
+}
 
 static struct v4l2_subdev *
 sun6i_video_remote_subdev(struct sun6i_video *video, u32 *pad)
@@ -41,180 +60,99 @@
 	return media_entity_to_v4l2_subdev(remote->entity);
 }
 
-/* Format */
-
-static const u32 sun6i_video_formats[] = {
-	V4L2_PIX_FMT_SBGGR8,
-	V4L2_PIX_FMT_SGBRG8,
-	V4L2_PIX_FMT_SGRBG8,
-	V4L2_PIX_FMT_SRGGB8,
-	V4L2_PIX_FMT_SBGGR10,
-	V4L2_PIX_FMT_SGBRG10,
-	V4L2_PIX_FMT_SGRBG10,
-	V4L2_PIX_FMT_SRGGB10,
-	V4L2_PIX_FMT_SBGGR12,
-	V4L2_PIX_FMT_SGBRG12,
-	V4L2_PIX_FMT_SGRBG12,
-	V4L2_PIX_FMT_SRGGB12,
-	V4L2_PIX_FMT_YUYV,
-	V4L2_PIX_FMT_YVYU,
-	V4L2_PIX_FMT_UYVY,
-	V4L2_PIX_FMT_VYUY,
-	V4L2_PIX_FMT_RGB565,
-	V4L2_PIX_FMT_RGB555,
-	V4L2_PIX_FMT_NV12_16L16,
-	V4L2_PIX_FMT_NV12,
-	V4L2_PIX_FMT_NV21,
-	V4L2_PIX_FMT_YUV420,
-	V4L2_PIX_FMT_YVU420,
-	V4L2_PIX_FMT_NV16,
-	V4L2_PIX_FMT_NV61,
-	V4L2_PIX_FMT_YUV422P,
-	V4L2_PIX_FMT_RGB565,
-	V4L2_PIX_FMT_RGB565X,
-	V4L2_PIX_FMT_JPEG,
-};
-
-static bool sun6i_video_format_check(u32 format)
-{
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(sun6i_video_formats); i++)
-		if (sun6i_video_formats[i] == format)
-			return true;
-
-	return false;
-}
-
-/* Video */
-
-static void sun6i_video_buffer_configure(struct sun6i_csi_device *csi_dev,
-					 struct sun6i_csi_buffer *csi_buffer)
-{
-	csi_buffer->queued_to_csi = true;
-	sun6i_csi_update_buf_addr(csi_dev, csi_buffer->dma_addr);
-}
-
-static void sun6i_video_configure(struct sun6i_csi_device *csi_dev,
-				  struct v4l2_fwnode_endpoint *vep)
-{
-	struct sun6i_video *video = &csi_dev->video;
-	struct sun6i_csi_config config = { 0 };
-
-	config.pixelformat = video->format.fmt.pix.pixelformat;
-	config.code = video->mbus_code;
-	config.field = video->format.fmt.pix.field;
-	config.width = video->format.fmt.pix.width;
-	config.height = video->format.fmt.pix.height;
-
-	sun6i_csi_update_config(csi_dev, &config, vep);
-}
-
-/* Queue */
-
-static int sun6i_video_queue_setup(struct vb2_queue *queue,
-				   unsigned int *buffers_count,
-				   unsigned int *planes_count,
+static int sun6i_video_queue_setup(struct vb2_queue *vq,
+				   unsigned int *nbuffers,
+				   unsigned int *nplanes,
 				   unsigned int sizes[],
 				   struct device *alloc_devs[])
 {
-	struct sun6i_csi_device *csi_dev = vb2_get_drv_priv(queue);
-	struct sun6i_video *video = &csi_dev->video;
-	unsigned int size = video->format.fmt.pix.sizeimage;
+	struct sun6i_video *video = vb2_get_drv_priv(vq);
+	unsigned int size = video->fmt.fmt.pix.sizeimage;
 
-	if (*planes_count)
+	if (*nplanes)
 		return sizes[0] < size ? -EINVAL : 0;
 
-	*planes_count = 1;
+	*nplanes = 1;
 	sizes[0] = size;
 
 	return 0;
 }
 
-static int sun6i_video_buffer_prepare(struct vb2_buffer *buffer)
+static int sun6i_video_buffer_prepare(struct vb2_buffer *vb)
 {
-	struct sun6i_csi_device *csi_dev = vb2_get_drv_priv(buffer->vb2_queue);
-	struct sun6i_video *video = &csi_dev->video;
-	struct v4l2_device *v4l2_dev = &csi_dev->v4l2.v4l2_dev;
-	struct vb2_v4l2_buffer *v4l2_buffer = to_vb2_v4l2_buffer(buffer);
-	struct sun6i_csi_buffer *csi_buffer =
-		container_of(v4l2_buffer, struct sun6i_csi_buffer, v4l2_buffer);
-	unsigned long size = video->format.fmt.pix.sizeimage;
-
-	if (vb2_plane_size(buffer, 0) < size) {
-		v4l2_err(v4l2_dev, "buffer too small (%lu < %lu)\n",
-			 vb2_plane_size(buffer, 0), size);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct sun6i_csi_buffer *buf =
+			container_of(vbuf, struct sun6i_csi_buffer, vb);
+	struct sun6i_video *video = vb2_get_drv_priv(vb->vb2_queue);
+	unsigned long size = video->fmt.fmt.pix.sizeimage;
+
+	if (vb2_plane_size(vb, 0) < size) {
+		v4l2_err(video->vdev.v4l2_dev, "buffer too small (%lu < %lu)\n",
+			 vb2_plane_size(vb, 0), size);
 		return -EINVAL;
 	}
 
-	vb2_set_plane_payload(buffer, 0, size);
+	vb2_set_plane_payload(vb, 0, size);
 
-	csi_buffer->dma_addr = vb2_dma_contig_plane_dma_addr(buffer, 0);
-	v4l2_buffer->field = video->format.fmt.pix.field;
+	buf->dma_addr = vb2_dma_contig_plane_dma_addr(vb, 0);
 
-	return 0;
-}
+	vbuf->field = video->fmt.fmt.pix.field;
 
-static void sun6i_video_buffer_queue(struct vb2_buffer *buffer)
-{
-	struct sun6i_csi_device *csi_dev = vb2_get_drv_priv(buffer->vb2_queue);
-	struct sun6i_video *video = &csi_dev->video;
-	struct vb2_v4l2_buffer *v4l2_buffer = to_vb2_v4l2_buffer(buffer);
-	struct sun6i_csi_buffer *csi_buffer =
-		container_of(v4l2_buffer, struct sun6i_csi_buffer, v4l2_buffer);
-	unsigned long flags;
-
-	spin_lock_irqsave(&video->dma_queue_lock, flags);
-	csi_buffer->queued_to_csi = false;
-	list_add_tail(&csi_buffer->list, &video->dma_queue);
-	spin_unlock_irqrestore(&video->dma_queue_lock, flags);
+	return 0;
 }
 
-static int sun6i_video_start_streaming(struct vb2_queue *queue,
-				       unsigned int count)
+static int sun6i_video_start_streaming(struct vb2_queue *vq, unsigned int count)
 {
-	struct sun6i_csi_device *csi_dev = vb2_get_drv_priv(queue);
-	struct sun6i_video *video = &csi_dev->video;
-	struct video_device *video_dev = &video->video_dev;
-	struct sun6i_csi_async_subdev *casd;
+	struct sun6i_video *video = vb2_get_drv_priv(vq);
 	struct sun6i_csi_buffer *buf;
 	struct sun6i_csi_buffer *next_buf;
+	struct sun6i_csi_config config;
 	struct v4l2_subdev *subdev;
+	struct sun6i_csi_async_subdev* casd;
 	unsigned long flags;
 	int ret;
 
 	video->sequence = 0;
 
-	ret = video_device_pipeline_alloc_start(video_dev);
+	ret = media_pipeline_start(&video->pad, &video->vdev.pipe);
 	if (ret < 0)
-		goto error_dma_queue_flush;
+		goto clear_dma_queue;
 
 	if (video->mbus_code == 0) {
 		ret = -EINVAL;
-		goto error_media_pipeline;
+		goto stop_media_pipeline;
 	}
 
 	subdev = sun6i_video_remote_subdev(video, NULL);
 	if (!subdev) {
 		ret = -EINVAL;
-		goto error_media_pipeline;
+		goto stop_media_pipeline;
 	}
 
 	casd = container_of(subdev->asd, struct sun6i_csi_async_subdev, asd);
 
-	sun6i_video_configure(csi_dev, &casd->vep);
+	config.pixelformat = video->fmt.fmt.pix.pixelformat;
+	config.code = video->mbus_code;
+	config.field = video->fmt.fmt.pix.field;
+	config.width = video->fmt.fmt.pix.width;
+	config.height = video->fmt.fmt.pix.height;
+
+	ret = sun6i_csi_update_config(video->csi, &config, &casd->vep);
+	if (ret < 0)
+		goto stop_media_pipeline;
 
 	spin_lock_irqsave(&video->dma_queue_lock, flags);
 
 	buf = list_first_entry(&video->dma_queue,
 			       struct sun6i_csi_buffer, list);
-	sun6i_video_buffer_configure(csi_dev, buf);
+	buf->queued_to_csi = true;
+	sun6i_csi_update_buf_addr(video->csi, buf->dma_addr);
 
-	sun6i_csi_set_stream(csi_dev, true);
+	sun6i_csi_set_stream(video->csi, true);
 
 	/*
 	 * CSI will lookup the next dma buffer for next frame before the
-	 * current frame done IRQ triggered. This is not documented
+	 * the current frame done IRQ triggered. This is not documented
 	 * but reported by Ondřej Jirman.
 	 * The BSP code has workaround for this too. It skip to mark the
 	 * first buffer as frame done for VB2 and pass the second buffer
@@ -230,37 +168,34 @@
 	 * would also drop frame when lacking of queued buffer.
 	 */
 	next_buf = list_next_entry(buf, list);
-	sun6i_video_buffer_configure(csi_dev, next_buf);
+	next_buf->queued_to_csi = true;
+	sun6i_csi_update_buf_addr(video->csi, next_buf->dma_addr);
 
 	spin_unlock_irqrestore(&video->dma_queue_lock, flags);
 
 	ret = v4l2_subdev_call(subdev, video, s_stream, 1);
 	if (ret && ret != -ENOIOCTLCMD)
-		goto error_stream;
+		goto stop_csi_stream;
 
 	return 0;
 
-error_stream:
-	sun6i_csi_set_stream(csi_dev, false);
-
-error_media_pipeline:
-	video_device_pipeline_stop(video_dev);
-
-error_dma_queue_flush:
+stop_csi_stream:
+	sun6i_csi_set_stream(video->csi, false);
+stop_media_pipeline:
+	media_pipeline_stop(&video->pad);
+clear_dma_queue:
 	spin_lock_irqsave(&video->dma_queue_lock, flags);
 	list_for_each_entry(buf, &video->dma_queue, list)
-		vb2_buffer_done(&buf->v4l2_buffer.vb2_buf,
-				VB2_BUF_STATE_QUEUED);
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);
 	INIT_LIST_HEAD(&video->dma_queue);
 	spin_unlock_irqrestore(&video->dma_queue_lock, flags);
 
 	return ret;
 }
 
-static void sun6i_video_stop_streaming(struct vb2_queue *queue)
+static void sun6i_video_stop_streaming(struct vb2_queue *vq)
 {
-	struct sun6i_csi_device *csi_dev = vb2_get_drv_priv(queue);
-	struct sun6i_video *video = &csi_dev->video;
+	struct sun6i_video *video = vb2_get_drv_priv(vq);
 	struct v4l2_subdev *subdev;
 	unsigned long flags;
 	struct sun6i_csi_buffer *buf;
@@ -269,32 +204,45 @@
 	if (subdev)
 		v4l2_subdev_call(subdev, video, s_stream, 0);
 
-	sun6i_csi_set_stream(csi_dev, false);
+	sun6i_csi_set_stream(video->csi, false);
 
-	video_device_pipeline_stop(&video->video_dev);
+	media_pipeline_stop(&video->pad);
 
 	/* Release all active buffers */
 	spin_lock_irqsave(&video->dma_queue_lock, flags);
 	list_for_each_entry(buf, &video->dma_queue, list)
-		vb2_buffer_done(&buf->v4l2_buffer.vb2_buf, VB2_BUF_STATE_ERROR);
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
 	INIT_LIST_HEAD(&video->dma_queue);
 	spin_unlock_irqrestore(&video->dma_queue_lock, flags);
 }
 
-void sun6i_video_frame_done(struct sun6i_csi_device *csi_dev)
+static void sun6i_video_buffer_queue(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct sun6i_csi_buffer *buf =
+			container_of(vbuf, struct sun6i_csi_buffer, vb);
+	struct sun6i_video *video = vb2_get_drv_priv(vb->vb2_queue);
+	unsigned long flags;
+
+	spin_lock_irqsave(&video->dma_queue_lock, flags);
+	buf->queued_to_csi = false;
+	list_add_tail(&buf->list, &video->dma_queue);
+	spin_unlock_irqrestore(&video->dma_queue_lock, flags);
+}
+
+void sun6i_video_frame_done(struct sun6i_video *video)
 {
-	struct sun6i_video *video = &csi_dev->video;
 	struct sun6i_csi_buffer *buf;
 	struct sun6i_csi_buffer *next_buf;
-	struct vb2_v4l2_buffer *v4l2_buffer;
+	struct vb2_v4l2_buffer *vbuf;
 
 	spin_lock(&video->dma_queue_lock);
 
 	buf = list_first_entry(&video->dma_queue,
 			       struct sun6i_csi_buffer, list);
 	if (list_is_last(&buf->list, &video->dma_queue)) {
-		dev_dbg(csi_dev->dev, "Frame dropped!\n");
-		goto complete;
+		dev_dbg(video->csi->dev, "Frame dropped!\n");
+		goto unlock;
 	}
 
 	next_buf = list_next_entry(buf, list);
@@ -304,157 +252,217 @@
 	 * for next ISR call.
 	 */
 	if (!next_buf->queued_to_csi) {
-		sun6i_video_buffer_configure(csi_dev, next_buf);
-		dev_dbg(csi_dev->dev, "Frame dropped!\n");
-		goto complete;
+		next_buf->queued_to_csi = true;
+		sun6i_csi_update_buf_addr(video->csi, next_buf->dma_addr);
+		dev_dbg(video->csi->dev, "Frame dropped!\n");
+		goto unlock;
 	}
 
 	list_del(&buf->list);
-	v4l2_buffer = &buf->v4l2_buffer;
-	v4l2_buffer->vb2_buf.timestamp = ktime_get_ns();
-	v4l2_buffer->sequence = video->sequence;
-	vb2_buffer_done(&v4l2_buffer->vb2_buf, VB2_BUF_STATE_DONE);
+	vbuf = &buf->vb;
+	vbuf->vb2_buf.timestamp = ktime_get_ns();
+	vbuf->sequence = video->sequence;
+	vb2_buffer_done(&vbuf->vb2_buf, VB2_BUF_STATE_DONE);
 
 	/* Prepare buffer for next frame but one.  */
 	if (!list_is_last(&next_buf->list, &video->dma_queue)) {
 		next_buf = list_next_entry(next_buf, list);
-		sun6i_video_buffer_configure(csi_dev, next_buf);
+		next_buf->queued_to_csi = true;
+		sun6i_csi_update_buf_addr(video->csi, next_buf->dma_addr);
 	} else {
-		dev_dbg(csi_dev->dev, "Next frame will be dropped!\n");
+		dev_dbg(video->csi->dev, "Next frame will be dropped!\n");
 	}
 
-complete:
+unlock:
 	video->sequence++;
 	spin_unlock(&video->dma_queue_lock);
 }
 
-static const struct vb2_ops sun6i_video_queue_ops = {
+static const struct vb2_ops sun6i_csi_vb2_ops = {
 	.queue_setup		= sun6i_video_queue_setup,
+	.wait_prepare		= vb2_ops_wait_prepare,
+	.wait_finish		= vb2_ops_wait_finish,
 	.buf_prepare		= sun6i_video_buffer_prepare,
-	.buf_queue		= sun6i_video_buffer_queue,
 	.start_streaming	= sun6i_video_start_streaming,
 	.stop_streaming		= sun6i_video_stop_streaming,
-	.wait_prepare		= vb2_ops_wait_prepare,
-	.wait_finish		= vb2_ops_wait_finish,
+	.buf_queue		= sun6i_video_buffer_queue,
 };
 
-/* V4L2 Device */
-
-static int sun6i_video_querycap(struct file *file, void *private,
-				struct v4l2_capability *capability)
+static int vidioc_querycap(struct file *file, void *priv,
+			   struct v4l2_capability *cap)
 {
-	struct sun6i_csi_device *csi_dev = video_drvdata(file);
-	struct video_device *video_dev = &csi_dev->video.video_dev;
+	struct sun6i_video *video = video_drvdata(file);
 
-	strscpy(capability->driver, SUN6I_CSI_NAME, sizeof(capability->driver));
-	strscpy(capability->card, video_dev->name, sizeof(capability->card));
-	snprintf(capability->bus_info, sizeof(capability->bus_info),
-		 "platform:%s", dev_name(csi_dev->dev));
+	strscpy(cap->driver, "sun6i-video", sizeof(cap->driver));
+	strscpy(cap->card, video->vdev.name, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",
+		 video->csi->dev->of_node->name);
 
 	return 0;
 }
 
-static int sun6i_video_enum_fmt(struct file *file, void *private,
-				struct v4l2_fmtdesc *fmtdesc)
+static int sun6i_get_available_formats(struct sun6i_video *video,
+				       u32 **pixelformats,
+				       u32 *pixelformats_size,
+				       struct v4l2_subdev_format *subdev_format)
 {
-	u32 index = fmtdesc->index;
+	struct v4l2_subdev *sd;
+	u32 sd_pad;
+	struct sun6i_csi_async_subdev* casd;
+	struct v4l2_subdev_format source_fmt = {};
+	int ret;
 
-	if (index >= ARRAY_SIZE(sun6i_video_formats))
-		return -EINVAL;
+	sd = sun6i_video_remote_subdev(video, &sd_pad);
+	if (!sd)
+		return -EPIPE;
 
-	fmtdesc->pixelformat = sun6i_video_formats[index];
+	casd = container_of(sd->asd, struct sun6i_csi_async_subdev, asd);
+
+	// Get format from subdev
+	source_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	source_fmt.pad = sd_pad;
+
+	ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &source_fmt);
+	if (ret < 0)
+		return ret;
+
+	// Get pixelformats compatible with the subdev bus format
+	if (!sun6i_csi_get_pixelformats(source_fmt.format.code,
+					&casd->vep,
+					pixelformats,
+					pixelformats_size)) {
+		return -EPIPE;
+	}
+
+	if (subdev_format)
+		*subdev_format = source_fmt;
 
 	return 0;
 }
 
-static int sun6i_video_g_fmt(struct file *file, void *private,
-			     struct v4l2_format *format)
+static int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,
+				   struct v4l2_fmtdesc *f)
 {
-	struct sun6i_csi_device *csi_dev = video_drvdata(file);
-	struct sun6i_video *video = &csi_dev->video;
+	struct sun6i_video *video = video_drvdata(file);
+	u32 index = f->index;
+	u32 *pixelformats, pixelformats_size;
+	int ret;
 
-	*format = video->format;
+	ret = sun6i_get_available_formats(video,
+					  &pixelformats,
+					  &pixelformats_size,
+					  NULL);
+	if (ret < 0)
+		return ret;
+
+	if (index >= pixelformats_size)
+		return -EINVAL;
+
+	f->pixelformat = pixelformats[index];
 
 	return 0;
 }
 
-static int sun6i_video_format_try(struct sun6i_video *video,
-				  struct v4l2_format *format)
+static int sun6i_video_try_fmt(struct sun6i_video *video,
+			       struct v4l2_format *f,
+			       struct v4l2_subdev_format *subdev_format)
 {
-	struct v4l2_pix_format *pix_format = &format->fmt.pix;
+	struct v4l2_pix_format *pixfmt = &f->fmt.pix;
 	int bpp;
 	u32 bpl_packed;
+	int ret;
+	u32 *pixelformats, pixelformats_size;
+
+	ret = sun6i_get_available_formats(video,
+					  &pixelformats,
+					  &pixelformats_size,
+					  subdev_format);
+	if (ret)
+		return ret;
 
-	if (!sun6i_video_format_check(pix_format->pixelformat))
-		pix_format->pixelformat = sun6i_video_formats[0];
+	if (!is_pixformat_valid(pixfmt->pixelformat,
+				pixelformats,
+				pixelformats_size)) {
+		pixfmt->pixelformat = pixelformats[0];
+	}
 
-	v4l_bound_align_image(&pix_format->width, MIN_WIDTH, MAX_WIDTH, 1,
-			      &pix_format->height, MIN_HEIGHT, MAX_WIDTH, 1, 1);
+	v4l_bound_align_image(&pixfmt->width, MIN_WIDTH, MAX_WIDTH, 1,
+			      &pixfmt->height, MIN_HEIGHT, MAX_WIDTH, 1, 1);
 
-	bpp = sun6i_csi_get_bpp(pix_format->pixelformat);
-        bpl_packed = (pix_format->width * bpp) / 8;
+	bpp = sun6i_csi_get_bpp(pixfmt->pixelformat);
+        bpl_packed = (pixfmt->width * bpp) / 8;
 
 	//XXX: only allow for YUYV and friends
-	if (pix_format->bytesperline < bpl_packed
-		|| pix_format->bytesperline > bpl_packed + 256)
-		pix_format->bytesperline = bpl_packed;
+	if (pixfmt->bytesperline < bpl_packed
+	    || pixfmt->bytesperline > bpl_packed + 256)
+		pixfmt->bytesperline = bpl_packed;
 
-	pix_format->sizeimage = pix_format->bytesperline * pix_format->height;
+	pixfmt->sizeimage = pixfmt->bytesperline * pixfmt->height;
 
-	if (pix_format->field == V4L2_FIELD_ANY)
-		pix_format->field = V4L2_FIELD_NONE;
+	if (pixfmt->field == V4L2_FIELD_ANY)
+		pixfmt->field = V4L2_FIELD_NONE;
 
-	if (pix_format->pixelformat == V4L2_PIX_FMT_JPEG)
-		pix_format->colorspace = V4L2_COLORSPACE_JPEG;
-	else
-		pix_format->colorspace = V4L2_COLORSPACE_SRGB;
+	pixfmt->colorspace = V4L2_COLORSPACE_RAW;
+	pixfmt->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	pixfmt->quantization = V4L2_QUANTIZATION_DEFAULT;
+	pixfmt->xfer_func = V4L2_XFER_FUNC_DEFAULT;
 
-	pix_format->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
-	pix_format->quantization = V4L2_QUANTIZATION_DEFAULT;
-	pix_format->xfer_func = V4L2_XFER_FUNC_DEFAULT;
+	return 0;
+}
+
+static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
+				struct v4l2_format *fmt)
+{
+	struct sun6i_video *video = video_drvdata(file);
+	int ret;
+
+	// Let the try_fmt set the video format to something available before
+	// returning, as the subdev may change it's bus format in-between calls.
+	ret = sun6i_video_try_fmt(video, &video->fmt, NULL);
+	if (ret < 0)
+		return ret;
+
+	*fmt = video->fmt;
 
 	return 0;
 }
 
-static int sun6i_video_format_set(struct sun6i_video *video,
-				  struct v4l2_format *format)
+static int sun6i_video_set_fmt(struct sun6i_video *video, struct v4l2_format *f)
 {
 	int ret;
 
-	ret = sun6i_video_format_try(video, format);
+	ret = sun6i_video_try_fmt(video, f, NULL);
 	if (ret)
 		return ret;
 
-	video->format = *format;
+	video->fmt = *f;
 
 	return 0;
 }
 
-static int sun6i_video_s_fmt(struct file *file, void *private,
-			     struct v4l2_format *format)
+static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
+				struct v4l2_format *f)
 {
-	struct sun6i_csi_device *csi_dev = video_drvdata(file);
-	struct sun6i_video *video = &csi_dev->video;
+	struct sun6i_video *video = video_drvdata(file);
 
-	if (vb2_is_busy(&video->queue))
+	if (vb2_is_busy(&video->vb2_vidq))
 		return -EBUSY;
 
-	return sun6i_video_format_set(video, format);
+	return sun6i_video_set_fmt(video, f);
 }
 
-static int sun6i_video_try_fmt(struct file *file, void *private,
-			       struct v4l2_format *format)
+static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
+				  struct v4l2_format *f)
 {
-	struct sun6i_csi_device *csi_dev = video_drvdata(file);
-	struct sun6i_video *video = &csi_dev->video;
+	struct sun6i_video *video = video_drvdata(file);
 
-	return sun6i_video_format_try(video, format);
+	return sun6i_video_try_fmt(video, f, NULL);
 }
 
 static int vidioc_enum_framesizes(struct file *file, void *priv,
 				  struct v4l2_frmsizeenum *f)
 {
-if (f->index != 0)
+	if (f->index != 0)
 		return -EINVAL;
 
 	f->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;
@@ -484,37 +492,35 @@
 	return 0;
 }
 
-static int sun6i_video_enum_input(struct file *file, void *private,
-				  struct v4l2_input *input)
+static int vidioc_enum_input(struct file *file, void *fh,
+			     struct v4l2_input *inp)
 {
-	if (input->index != 0)
+	if (inp->index != 0)
 		return -EINVAL;
 
-	input->type = V4L2_INPUT_TYPE_CAMERA;
-	strscpy(input->name, "Camera", sizeof(input->name));
+	strscpy(inp->name, "camera", sizeof(inp->name));
+	inp->type = V4L2_INPUT_TYPE_CAMERA;
 
 	return 0;
 }
 
-static int sun6i_video_g_input(struct file *file, void *private,
-			       unsigned int *index)
+static int vidioc_g_input(struct file *file, void *fh, unsigned int *i)
 {
-	*index = 0;
+	*i = 0;
 
 	return 0;
 }
 
-static int sun6i_video_s_input(struct file *file, void *private,
-			       unsigned int index)
+static int vidioc_s_input(struct file *file, void *fh, unsigned int i)
 {
-	if (index != 0)
+	if (i != 0)
 		return -EINVAL;
 
 	return 0;
 }
 
-static int sun6i_vidioc_g_parm(struct file *file, void *priv,
-			       struct v4l2_streamparm *p)
+static int vidioc_g_parm(struct file *file, void *priv,
+			 struct v4l2_streamparm *p)
 {
 	struct sun6i_video *video = video_drvdata(file);
 	struct v4l2_subdev *subdev;
@@ -526,8 +532,8 @@
 	return v4l2_g_parm_cap(video_devdata(file), subdev, p);
 }
 
-static int sun6i_vidioc_s_parm(struct file *file, void *priv,
-			       struct v4l2_streamparm *p)
+static int vidioc_s_parm(struct file *file, void *priv,
+			 struct v4l2_streamparm *p)
 {
 	struct sun6i_video *video = video_drvdata(file);
 	struct v4l2_subdev *subdev;
@@ -540,39 +546,43 @@
 }
 
 static const struct v4l2_ioctl_ops sun6i_video_ioctl_ops = {
-	.vidioc_querycap		= sun6i_video_querycap,
+	.vidioc_querycap		= vidioc_querycap,
+	.vidioc_enum_fmt_vid_cap	= vidioc_enum_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap		= vidioc_g_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap		= vidioc_s_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap		= vidioc_try_fmt_vid_cap,
 
-	.vidioc_enum_fmt_vid_cap	= sun6i_video_enum_fmt,
-	.vidioc_g_fmt_vid_cap		= sun6i_video_g_fmt,
-	.vidioc_s_fmt_vid_cap		= sun6i_video_s_fmt,
-	.vidioc_try_fmt_vid_cap		= sun6i_video_try_fmt,
 	.vidioc_enum_framesizes		= vidioc_enum_framesizes,
 	.vidioc_enum_frameintervals	= vidioc_enum_frameintervals,
 
-	.vidioc_enum_input		= sun6i_video_enum_input,
-	.vidioc_g_input			= sun6i_video_g_input,
-	.vidioc_s_input			= sun6i_video_s_input,
+	.vidioc_enum_input		= vidioc_enum_input,
+	.vidioc_s_input			= vidioc_s_input,
+	.vidioc_g_input			= vidioc_g_input,
 
-	.vidioc_g_parm			= sun6i_vidioc_g_parm,
-	.vidioc_s_parm			= sun6i_vidioc_s_parm,
+	.vidioc_g_parm			= vidioc_g_parm,
+	.vidioc_s_parm			= vidioc_s_parm,
 
-	.vidioc_create_bufs		= vb2_ioctl_create_bufs,
-	.vidioc_prepare_buf		= vb2_ioctl_prepare_buf,
 	.vidioc_reqbufs			= vb2_ioctl_reqbufs,
 	.vidioc_querybuf		= vb2_ioctl_querybuf,
-	.vidioc_expbuf			= vb2_ioctl_expbuf,
 	.vidioc_qbuf			= vb2_ioctl_qbuf,
+	.vidioc_expbuf			= vb2_ioctl_expbuf,
 	.vidioc_dqbuf			= vb2_ioctl_dqbuf,
+	.vidioc_create_bufs		= vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf		= vb2_ioctl_prepare_buf,
 	.vidioc_streamon		= vb2_ioctl_streamon,
 	.vidioc_streamoff		= vb2_ioctl_streamoff,
-};
 
-/* V4L2 File */
+	.vidioc_log_status		= v4l2_ctrl_log_status,
+	.vidioc_subscribe_event		= v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event	= v4l2_event_unsubscribe,
+};
 
+/* -----------------------------------------------------------------------------
+ * V4L2 file operations
+ */
 static int sun6i_video_open(struct file *file)
 {
-	struct sun6i_csi_device *csi_dev = video_drvdata(file);
-	struct sun6i_video *video = &csi_dev->video;
+	struct sun6i_video *video = video_drvdata(file);
 	int ret = 0;
 
 	if (mutex_lock_interruptible(&video->lock))
@@ -580,48 +590,45 @@
 
 	ret = v4l2_fh_open(file);
 	if (ret < 0)
-		goto error_lock;
+		goto unlock;
 
-	ret = v4l2_pipeline_pm_get(&video->video_dev.entity);
+	ret = v4l2_pipeline_pm_get(&video->vdev.entity);
 	if (ret < 0)
-		goto error_v4l2_fh;
+		goto fh_release;
 
-	/* Power on at first open. */
-	if (v4l2_fh_is_singular_file(file)) {
-		ret = sun6i_csi_set_power(csi_dev, true);
-		if (ret < 0)
-			goto error_v4l2_fh;
-	}
+	/* check if already powered */
+	if (!v4l2_fh_is_singular_file(file))
+		goto unlock;
 
-	mutex_unlock(&video->lock);
+	ret = sun6i_csi_set_power(video->csi, true);
+	if (ret < 0)
+		goto fh_release;
 
+	mutex_unlock(&video->lock);
 	return 0;
 
-error_v4l2_fh:
+fh_release:
 	v4l2_fh_release(file);
-
-error_lock:
+unlock:
 	mutex_unlock(&video->lock);
-
 	return ret;
 }
 
 static int sun6i_video_close(struct file *file)
 {
-	struct sun6i_csi_device *csi_dev = video_drvdata(file);
-	struct sun6i_video *video = &csi_dev->video;
-	bool last_close;
+	struct sun6i_video *video = video_drvdata(file);
+	bool last_fh;
 
 	mutex_lock(&video->lock);
 
-	last_close = v4l2_fh_is_singular_file(file);
+	last_fh = v4l2_fh_is_singular_file(file);
 
 	_vb2_fop_release(file, NULL);
-	v4l2_pipeline_pm_put(&video->video_dev.entity);
 
-	/* Power off at last close. */
-	if (last_close)
-		sun6i_csi_set_power(csi_dev, false);
+	v4l2_pipeline_pm_put(&video->vdev.entity);
+
+	if (last_fh)
+		sun6i_csi_set_power(video->csi, false);
 
 	mutex_unlock(&video->lock);
 
@@ -637,65 +644,38 @@
 	.poll		= vb2_fop_poll
 };
 
-/* Media Entity */
-
-static int sun6i_video_link_validate_get_format(struct media_pad *pad,
-						struct v4l2_subdev_format *fmt,
-						struct v4l2_fwnode_endpoint **vep)
-{
-	if (is_media_entity_v4l2_subdev(pad->entity)) {
-		struct v4l2_subdev *sd =
-				media_entity_to_v4l2_subdev(pad->entity);
-		struct sun6i_csi_async_subdev *casd =
-			container_of(sd->asd, struct sun6i_csi_async_subdev, asd);
-
-		*vep = &casd->vep;
-
-		fmt->which = V4L2_SUBDEV_FORMAT_ACTIVE;
-		fmt->pad = pad->index;
-		return v4l2_subdev_call(sd, pad, get_fmt, NULL, fmt);
-	}
-
-	return -EINVAL;
-}
+/* -----------------------------------------------------------------------------
+ * Media Operations
+ */
 
 static int sun6i_video_link_validate(struct media_link *link)
 {
 	struct video_device *vdev = container_of(link->sink->entity,
 						 struct video_device, entity);
-	struct sun6i_csi_device *csi_dev = video_get_drvdata(vdev);
-	struct sun6i_video *video = &csi_dev->video;
-	struct v4l2_subdev_format source_fmt;
-	struct v4l2_fwnode_endpoint *vep;
+	struct sun6i_video *video = video_get_drvdata(vdev);
+	struct v4l2_subdev_format source_fmt = {};
 	int ret;
 
 	video->mbus_code = 0;
 
 	if (!media_pad_remote_pad_first(link->sink->entity->pads)) {
-		dev_info(csi_dev->dev, "video node %s pad not connected\n",
-			 vdev->name);
+		dev_info(video->csi->dev,
+			 "video node %s pad not connected\n", vdev->name);
 		return -ENOLINK;
 	}
 
-	ret = sun6i_video_link_validate_get_format(link->source, &source_fmt, &vep);
+	if (!is_media_entity_v4l2_subdev(link->source->entity))
+		return -EINVAL;
+
+	ret = sun6i_video_try_fmt(video, &video->fmt, &source_fmt);
 	if (ret < 0)
 		return ret;
 
-	if (!sun6i_csi_is_format_supported(csi_dev,
-					   video->format.fmt.pix.pixelformat,
-					   source_fmt.format.code, vep)) {
-		dev_err(csi_dev->dev,
-			"Unsupported pixformat: 0x%x with mbus code: 0x%x!\n",
-			video->format.fmt.pix.pixelformat,
-			source_fmt.format.code);
-		return -EPIPE;
-	}
-
-	if (source_fmt.format.width != video->format.fmt.pix.width ||
-	    source_fmt.format.height != video->format.fmt.pix.height) {
-		dev_err(csi_dev->dev,
+	if (source_fmt.format.width != video->fmt.fmt.pix.width ||
+	    source_fmt.format.height != video->fmt.fmt.pix.height) {
+		dev_err(video->csi->dev,
 			"Wrong width or height %ux%u (%ux%u expected)\n",
-			video->format.fmt.pix.width, video->format.fmt.pix.height,
+			video->fmt.fmt.pix.width, video->fmt.fmt.pix.height,
 			source_fmt.format.width, source_fmt.format.height);
 		return -EPIPE;
 	}
@@ -709,9 +689,10 @@
 				  const struct media_pad *local,
 				  const struct media_pad *remote, u32 flags)
 {
-	/* Allow to enable one link only. */
-	if ((flags & MEDIA_LNK_FL_ENABLED) && media_pad_remote_pad_first(local))
-		return -EBUSY;
+        if (flags & MEDIA_LNK_FL_ENABLED) {
+                if (media_pad_remote_pad_first(local))
+                        return -EBUSY;
+	}
 
 	return 0;
 }
@@ -721,108 +702,93 @@
 	.link_setup = sun6i_video_link_setup,
 };
 
-/* Video */
-
-int sun6i_video_setup(struct sun6i_csi_device *csi_dev)
+int sun6i_video_init(struct sun6i_video *video, struct sun6i_csi *csi,
+		     const char *name)
 {
-	struct sun6i_video *video = &csi_dev->video;
-	struct v4l2_device *v4l2_dev = &csi_dev->v4l2.v4l2_dev;
-	struct video_device *video_dev = &video->video_dev;
-	struct vb2_queue *queue = &video->queue;
-	struct media_pad *pad = &video->pad;
-	struct v4l2_format format = { 0 };
-	struct v4l2_pix_format *pix_format = &format.fmt.pix;
+	struct video_device *vdev = &video->vdev;
+	struct vb2_queue *vidq = &video->vb2_vidq;
+	struct v4l2_format fmt = { 0 };
 	int ret;
 
-	/* Media Entity */
-
-	video_dev->entity.ops = &sun6i_video_media_ops;
-
-	/* Media Pad */
+	video->csi = csi;
 
-	pad->flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT;
-
-	ret = media_entity_pads_init(&video_dev->entity, 1, pad);
+	/* Initialize the media entity... */
+	video->pad.flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT;
+	vdev->entity.ops = &sun6i_video_media_ops;
+	ret = media_entity_pads_init(&vdev->entity, 1, &video->pad);
 	if (ret < 0)
 		return ret;
 
-	/* DMA queue */
+	mutex_init(&video->lock);
 
 	INIT_LIST_HEAD(&video->dma_queue);
 	spin_lock_init(&video->dma_queue_lock);
 
 	video->sequence = 0;
 
-	/* Queue */
-
-	mutex_init(&video->lock);
-
-	queue->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	queue->io_modes = VB2_MMAP | VB2_DMABUF;
-	queue->buf_struct_size = sizeof(struct sun6i_csi_buffer);
-	queue->ops = &sun6i_video_queue_ops;
-	queue->mem_ops = &vb2_dma_contig_memops;
-	queue->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
-	queue->lock = &video->lock;
-	queue->dev = csi_dev->dev;
-	queue->drv_priv = csi_dev;
-
-	/* Make sure non-dropped frame. */
-	queue->min_buffers_needed = 3;
+	/* Initialize videobuf2 queue */
+	vidq->type			= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	vidq->io_modes			= VB2_MMAP | VB2_DMABUF;
+	vidq->drv_priv			= video;
+	vidq->buf_struct_size		= sizeof(struct sun6i_csi_buffer);
+	vidq->ops			= &sun6i_csi_vb2_ops;
+	vidq->mem_ops			= &vb2_dma_contig_memops;
+	vidq->timestamp_flags		= V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	vidq->lock			= &video->lock;
+	/* Make sure non-dropped frame */
+	vidq->min_buffers_needed	= 3;
+	vidq->dev			= csi->dev;
 
-	ret = vb2_queue_init(queue);
+	ret = vb2_queue_init(vidq);
 	if (ret) {
-		v4l2_err(v4l2_dev, "failed to initialize vb2 queue: %d\n", ret);
-		goto error_media_entity;
+		v4l2_err(&csi->v4l2_dev, "vb2_queue_init failed: %d\n", ret);
+		goto clean_entity;
 	}
 
-	/* V4L2 Format */
+	/* Register video device */
+	strscpy(vdev->name, name, sizeof(vdev->name));
+	vdev->release		= video_device_release_empty;
+	vdev->fops		= &sun6i_video_fops;
+	vdev->ioctl_ops		= &sun6i_video_ioctl_ops;
+	vdev->vfl_type		= VFL_TYPE_VIDEO;
+	vdev->vfl_dir		= VFL_DIR_RX;
+	vdev->v4l2_dev		= &csi->v4l2_dev;
+	vdev->queue		= vidq;
+	vdev->lock		= &video->lock;
+	vdev->device_caps	= V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_IO_MC;
+	video_set_drvdata(vdev, video);
+
+	/* Setup default format */
+	fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_SBGGR8;
+	fmt.fmt.pix.width = 1280;
+	fmt.fmt.pix.height = 720;
+	fmt.fmt.pix.field = V4L2_FIELD_NONE;
+	fmt.fmt.pix.sizeimage = fmt.fmt.pix.width * fmt.fmt.pix.height;
+	fmt.fmt.pix.colorspace = V4L2_COLORSPACE_RAW;
+	fmt.fmt.pix.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	fmt.fmt.pix.quantization = V4L2_QUANTIZATION_DEFAULT;
+	fmt.fmt.pix.xfer_func = V4L2_XFER_FUNC_DEFAULT;
+	video->fmt = fmt;
 
-	format.type = queue->type;
-	pix_format->pixelformat = sun6i_video_formats[0];
-	pix_format->width = 1280;
-	pix_format->height = 720;
-	pix_format->field = V4L2_FIELD_NONE;
-
-	sun6i_video_format_set(video, &format);
-
-	/* Video Device */
-
-	strscpy(video_dev->name, SUN6I_CSI_NAME, sizeof(video_dev->name));
-	video_dev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING | V4L2_CAP_IO_MC;
-	video_dev->vfl_dir = VFL_DIR_RX;
-	video_dev->release = video_device_release_empty;
-	video_dev->fops = &sun6i_video_fops;
-	video_dev->ioctl_ops = &sun6i_video_ioctl_ops;
-	video_dev->v4l2_dev = v4l2_dev;
-	video_dev->queue = queue;
-	video_dev->lock = &video->lock;
-
-	video_set_drvdata(video_dev, csi_dev);
-
-	ret = video_register_device(video_dev, VFL_TYPE_VIDEO, -1);
+	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
 	if (ret < 0) {
-		v4l2_err(v4l2_dev, "failed to register video device: %d\n",
-			 ret);
-		goto error_media_entity;
+		v4l2_err(&csi->v4l2_dev,
+			 "video_register_device failed: %d\n", ret);
+		goto clean_entity;
 	}
 
 	return 0;
 
-error_media_entity:
-	media_entity_cleanup(&video_dev->entity);
-
+clean_entity:
+	media_entity_cleanup(&video->vdev.entity);
 	mutex_destroy(&video->lock);
-
 	return ret;
 }
 
-void sun6i_video_cleanup(struct sun6i_csi_device *csi_dev)
+void sun6i_video_cleanup(struct sun6i_video *video)
 {
-	struct sun6i_video *video = &csi_dev->video;
-	struct video_device *video_dev = &video->video_dev;
-
-	vb2_video_unregister_device(video_dev);
-	media_entity_cleanup(&video_dev->entity);
+	vb2_video_unregister_device(&video->vdev);
+	media_entity_cleanup(&video->vdev.entity);
 	mutex_destroy(&video->lock);
 }
--- a/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.h	2023-01-13 15:19:21.282349127 +0300
+++ b/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.h	2023-01-13 16:15:00.720400678 +0300
@@ -8,23 +8,14 @@
 #ifndef __SUN6I_CSI_H__
 #define __SUN6I_CSI_H__
 
+#include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-fwnode.h>
 #include <media/v4l2-mc.h>
-#include <media/videobuf2-v4l2.h>
 
 #include "sun6i_video.h"
 
-#define SUN6I_CSI_NAME		"sun6i-csi"
-#define SUN6I_CSI_DESCRIPTION	"Allwinner A31 CSI Device"
-
-struct sun6i_csi_buffer {
-	struct vb2_v4l2_buffer		v4l2_buffer;
-	struct list_head		list;
-
-	dma_addr_t			dma_addr;
-	bool				queued_to_csi;
-};
+#define MAX_ENDPOINTS 4
 
 /**
  * struct sun6i_csi_config - configs for sun6i csi
@@ -42,86 +33,69 @@
 	u32		height;
 };
 
-struct sun6i_csi_v4l2 {
+struct sun6i_csi {
+	struct device			*dev;
+	struct v4l2_ctrl_handler	ctrl_handler;
 	struct v4l2_device		v4l2_dev;
 	struct media_device		media_dev;
 	struct v4l2_async_notifier	notifier;
-};
-
-struct sun6i_csi_device {
-	struct device			*dev;
-
 	struct sun6i_csi_config		config;
-	struct sun6i_csi_v4l2		v4l2;
 	struct sun6i_video		video;
-
-	struct regmap			*regmap;
-	struct clk			*clock_mod;
-	struct clk			*clock_ram;
-	struct reset_control		*reset;
-
-	int				planar_offset[3];
-};
-
-struct sun6i_csi_variant {
-	unsigned long	clock_mod_rate;
 };
 
 struct sun6i_csi_async_subdev {
 	struct v4l2_async_subdev	asd; /* must be first */
-
-	/* csi side video port settings for this subdev */
 	struct v4l2_fwnode_endpoint	vep;
 };
 
+struct sun6i_csi_mode {
+	u32	mbus_code;
+	u32	*pixelformats;
+	u32	pixelformats_size;
+};
+
 /**
- * sun6i_csi_is_format_supported() - check if the format supported by csi
- * @csi_dev:	pointer to the csi device
- * @pixformat:	v4l2 pixel format (V4L2_PIX_FMT_*)
- * @mbus_code:	media bus format code (MEDIA_BUS_FMT_*)
- * @vep:	parsed CSI side bus endpoint configuration
- *
- * Return: true if format is supported, false otherwise.
- */
-bool sun6i_csi_is_format_supported(struct sun6i_csi_device *csi_dev,
-				   u32 pixformat, u32 mbus_code,
-				   struct v4l2_fwnode_endpoint *vep);
+ * sun6i_csi_get_pixelformats() - get the valid pixel formats for a bus code
+ * @mbus_code:		the bus code
+ * @vep:		parsed CSI side bus endpoint configuration
+ * @pixelformats:	returned list of valid pixel formats
+ * @pixelformats_size:	size of pixelformats
+ */
+bool sun6i_csi_get_pixelformats(u32 mbus_code,
+				struct v4l2_fwnode_endpoint* vep,
+				u32 **pixelformats,
+				u32 *pixelformats_size);
 
 /**
  * sun6i_csi_set_power() - power on/off the csi
- * @csi_dev:	pointer to the csi device
+ * @csi:	pointer to the csi
  * @enable:	on/off
- *
- * Return: 0 if successful, error code otherwise.
  */
-int sun6i_csi_set_power(struct sun6i_csi_device *csi_dev, bool enable);
+int sun6i_csi_set_power(struct sun6i_csi *csi, bool enable);
 
 /**
  * sun6i_csi_update_config() - update the csi register settings
- * @csi_dev:	pointer to the csi device
+ * @csi:	pointer to the csi
  * @config:	see struct sun6i_csi_config
- * @vep:	parsed CSI side bus endpoint configuration
- *
- * Return: 0 if successful, error code otherwise.
+ * @vep:        parsed CSI side bus endpoint configuration
  */
-int sun6i_csi_update_config(struct sun6i_csi_device *csi_dev,
+int sun6i_csi_update_config(struct sun6i_csi *csi,
 			    struct sun6i_csi_config *config,
-			    struct v4l2_fwnode_endpoint *vep);
+			    struct v4l2_fwnode_endpoint* vep);
 
 /**
  * sun6i_csi_update_buf_addr() - update the csi frame buffer address
- * @csi_dev:	pointer to the csi device
+ * @csi:	pointer to the csi
  * @addr:	frame buffer's physical address
  */
-void sun6i_csi_update_buf_addr(struct sun6i_csi_device *csi_dev,
-			       dma_addr_t addr);
+void sun6i_csi_update_buf_addr(struct sun6i_csi *csi, dma_addr_t addr);
 
 /**
  * sun6i_csi_set_stream() - start/stop csi streaming
- * @csi_dev:	pointer to the csi device
+ * @csi:	pointer to the csi
  * @enable:	start/stop
  */
-void sun6i_csi_set_stream(struct sun6i_csi_device *csi_dev, bool enable);
+void sun6i_csi_set_stream(struct sun6i_csi *csi, bool enable);
 
 /* get bpp form v4l2 pixformat */
 static inline int sun6i_csi_get_bpp(unsigned int pixformat)
--- a/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.c	2023-01-13 15:19:27.158242700 +0300
+++ b/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.c	2023-01-13 17:54:22.113842414 +0300
@@ -23,153 +23,164 @@
 #include <linux/sched.h>
 #include <linux/sizes.h>
 #include <linux/slab.h>
-#include <media/v4l2-mc.h>
 
 #include "sun6i_csi.h"
 #include "sun6i_csi_reg.h"
 
-/* Helpers */
+#define MODULE_NAME	"sun6i-csi"
+
+struct sun6i_csi_dev {
+	struct sun6i_csi		csi;
+	struct device			*dev;
+
+	struct regmap			*regmap;
+	struct clk			*clk_mod;
+	struct clk			*clk_ram;
+	struct reset_control		*rstc_bus;
+
+	int				planar_offset[3];
+};
+
+static inline struct sun6i_csi_dev *sun6i_csi_to_dev(struct sun6i_csi *csi)
+{
+	return container_of(csi, struct sun6i_csi_dev, csi);
+}
+
+static u32 yuv_pixelformats[] = {
+	V4L2_PIX_FMT_NV12_16L16,
+	V4L2_PIX_FMT_NV12,
+	V4L2_PIX_FMT_NV21,
+	V4L2_PIX_FMT_NV16,
+	V4L2_PIX_FMT_NV61,
+	V4L2_PIX_FMT_YUV420,
+	V4L2_PIX_FMT_YVU420,
+	V4L2_PIX_FMT_YUV422P,
+};
+
+static struct sun6i_csi_mode wide_bus_modes[] = {
+	{ MEDIA_BUS_FMT_UYVY8_1X16, yuv_pixelformats, ARRAY_SIZE(yuv_pixelformats) },
+	{ MEDIA_BUS_FMT_VYUY8_1X16, yuv_pixelformats, ARRAY_SIZE(yuv_pixelformats) },
+	{ MEDIA_BUS_FMT_YUYV8_1X16, yuv_pixelformats, ARRAY_SIZE(yuv_pixelformats) },
+	{ MEDIA_BUS_FMT_YVYU8_1X16, yuv_pixelformats, ARRAY_SIZE(yuv_pixelformats) },
+};
+
+static struct sun6i_csi_mode modes[] = {
+	{ MEDIA_BUS_FMT_SBGGR8_1X8, (u32[]) { V4L2_PIX_FMT_SBGGR8 }, 1 },
+	{ MEDIA_BUS_FMT_SGBRG8_1X8, (u32[]) { V4L2_PIX_FMT_SGBRG8 }, 1 },
+	{ MEDIA_BUS_FMT_SGRBG8_1X8, (u32[]) { V4L2_PIX_FMT_SGRBG8 }, 1 },
+	{ MEDIA_BUS_FMT_SRGGB8_1X8, (u32[]) { V4L2_PIX_FMT_SRGGB8 }, 1 },
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, (u32[]) { V4L2_PIX_FMT_SBGGR10 }, 1 },
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, (u32[]) { V4L2_PIX_FMT_SGBRG10 }, 1 },
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, (u32[]) { V4L2_PIX_FMT_SGRBG10 }, 1 },
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, (u32[]) { V4L2_PIX_FMT_SRGGB10 }, 1 },
+	{ MEDIA_BUS_FMT_SBGGR12_1X12, (u32[]) { V4L2_PIX_FMT_SBGGR12 }, 1 },
+	{ MEDIA_BUS_FMT_SGBRG12_1X12, (u32[]) { V4L2_PIX_FMT_SGBRG12 }, 1 },
+	{ MEDIA_BUS_FMT_SGRBG12_1X12, (u32[]) { V4L2_PIX_FMT_SGRBG12 }, 1 },
+	{ MEDIA_BUS_FMT_SRGGB12_1X12, (u32[]) { V4L2_PIX_FMT_SRGGB12 }, 1 },
+	{ MEDIA_BUS_FMT_YUYV8_2X8, (u32[]) { V4L2_PIX_FMT_YUYV }, 1 },
+	{ MEDIA_BUS_FMT_YVYU8_2X8, (u32[]) { V4L2_PIX_FMT_YVYU }, 1 },
+	{ MEDIA_BUS_FMT_UYVY8_2X8, (u32[]) { V4L2_PIX_FMT_UYVY }, 1 },
+	{ MEDIA_BUS_FMT_VYUY8_2X8, (u32[]) { V4L2_PIX_FMT_VYUY }, 1 },
+	{ MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE, (u32[]) { V4L2_PIX_FMT_RGB555 }, 1 },
+	{ MEDIA_BUS_FMT_UYVY8_2X8, yuv_pixelformats, ARRAY_SIZE(yuv_pixelformats) },
+	{ MEDIA_BUS_FMT_VYUY8_2X8, yuv_pixelformats, ARRAY_SIZE(yuv_pixelformats) },
+	{ MEDIA_BUS_FMT_YUYV8_2X8, yuv_pixelformats, ARRAY_SIZE(yuv_pixelformats) },
+	{ MEDIA_BUS_FMT_YVYU8_2X8, yuv_pixelformats, ARRAY_SIZE(yuv_pixelformats) },
+	{ MEDIA_BUS_FMT_RGB565_2X8_LE, (u32[]) { V4L2_PIX_FMT_RGB565 }, 1 },
+	{ MEDIA_BUS_FMT_RGB565_2X8_BE, (u32[]) { V4L2_PIX_FMT_RGB565X }, 1 },
+	{ MEDIA_BUS_FMT_JPEG_1X8, (u32[]) { V4L2_PIX_FMT_JPEG }, 1 },
+};
 
 /* TODO add 10&12 bit YUV, RGB support */
-bool sun6i_csi_is_format_supported(struct sun6i_csi_device *csi_dev,
-				   u32 pixformat, u32 mbus_code,
-				   struct v4l2_fwnode_endpoint *vep)
+bool sun6i_csi_get_pixelformats(u32 mbus_code,
+				struct v4l2_fwnode_endpoint* vep,
+				u32 **pixelformats,
+				u32 *pixelformats_size)
 {
+	u32 i;
+
 	/*
 	 * Some video receivers have the ability to be compatible with
 	 * 8bit and 16bit bus width.
 	 * Identify the media bus format from device tree.
 	 */
 	if ((vep->bus_type == V4L2_MBUS_PARALLEL
-	     || vep->bus_type == V4L2_MBUS_BT656)
-	     && vep->bus.parallel.bus_width == 16) {
-		switch (pixformat) {
-		case V4L2_PIX_FMT_NV12_16L16:
-		case V4L2_PIX_FMT_NV12:
-		case V4L2_PIX_FMT_NV21:
-		case V4L2_PIX_FMT_NV16:
-		case V4L2_PIX_FMT_NV61:
-		case V4L2_PIX_FMT_YUV420:
-		case V4L2_PIX_FMT_YVU420:
-		case V4L2_PIX_FMT_YUV422P:
-			switch (mbus_code) {
-			case MEDIA_BUS_FMT_UYVY8_1X16:
-			case MEDIA_BUS_FMT_VYUY8_1X16:
-			case MEDIA_BUS_FMT_YUYV8_1X16:
-			case MEDIA_BUS_FMT_YVYU8_1X16:
+	    || vep->bus_type == V4L2_MBUS_BT656)
+	    && vep->bus.parallel.bus_width == 16) {
+		for (i = 0; i < ARRAY_SIZE(wide_bus_modes); ++i) {
+			if (modes[i].mbus_code == mbus_code) {
+				*pixelformats = modes[i].pixelformats;
+				*pixelformats_size = modes[i].pixelformats_size;
 				return true;
-			default:
-				dev_dbg(csi_dev->dev,
-					"Unsupported mbus code: 0x%x\n",
-					mbus_code);
-				break;
 			}
-			break;
-		default:
-			dev_dbg(csi_dev->dev, "Unsupported pixformat: 0x%x\n",
-				pixformat);
-			break;
 		}
 		return false;
 	}
 
-	switch (pixformat) {
-	case V4L2_PIX_FMT_SBGGR8:
-		return (mbus_code == MEDIA_BUS_FMT_SBGGR8_1X8);
-	case V4L2_PIX_FMT_SGBRG8:
-		return (mbus_code == MEDIA_BUS_FMT_SGBRG8_1X8);
-	case V4L2_PIX_FMT_SGRBG8:
-		return (mbus_code == MEDIA_BUS_FMT_SGRBG8_1X8);
-	case V4L2_PIX_FMT_SRGGB8:
-		return (mbus_code == MEDIA_BUS_FMT_SRGGB8_1X8);
-	case V4L2_PIX_FMT_SBGGR10:
-		return (mbus_code == MEDIA_BUS_FMT_SBGGR10_1X10);
-	case V4L2_PIX_FMT_SGBRG10:
-		return (mbus_code == MEDIA_BUS_FMT_SGBRG10_1X10);
-	case V4L2_PIX_FMT_SGRBG10:
-		return (mbus_code == MEDIA_BUS_FMT_SGRBG10_1X10);
-	case V4L2_PIX_FMT_SRGGB10:
-		return (mbus_code == MEDIA_BUS_FMT_SRGGB10_1X10);
-	case V4L2_PIX_FMT_SBGGR12:
-		return (mbus_code == MEDIA_BUS_FMT_SBGGR12_1X12);
-	case V4L2_PIX_FMT_SGBRG12:
-		return (mbus_code == MEDIA_BUS_FMT_SGBRG12_1X12);
-	case V4L2_PIX_FMT_SGRBG12:
-		return (mbus_code == MEDIA_BUS_FMT_SGRBG12_1X12);
-	case V4L2_PIX_FMT_SRGGB12:
-		return (mbus_code == MEDIA_BUS_FMT_SRGGB12_1X12);
-
-	case V4L2_PIX_FMT_YUYV:
-		return (mbus_code == MEDIA_BUS_FMT_YUYV8_2X8);
-	case V4L2_PIX_FMT_YVYU:
-		return (mbus_code == MEDIA_BUS_FMT_YVYU8_2X8);
-	case V4L2_PIX_FMT_UYVY:
-		return (mbus_code == MEDIA_BUS_FMT_UYVY8_2X8);
-	case V4L2_PIX_FMT_VYUY:
-		return (mbus_code == MEDIA_BUS_FMT_VYUY8_2X8);
-	case V4L2_PIX_FMT_RGB555:
-		return mbus_code == MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE;
-	case V4L2_PIX_FMT_NV12_16L16:
-	case V4L2_PIX_FMT_NV12:
-	case V4L2_PIX_FMT_NV21:
-	case V4L2_PIX_FMT_NV16:
-	case V4L2_PIX_FMT_NV61:
-	case V4L2_PIX_FMT_YUV420:
-	case V4L2_PIX_FMT_YVU420:
-	case V4L2_PIX_FMT_YUV422P:
-		switch (mbus_code) {
-		case MEDIA_BUS_FMT_UYVY8_2X8:
-		case MEDIA_BUS_FMT_VYUY8_2X8:
-		case MEDIA_BUS_FMT_YUYV8_2X8:
-		case MEDIA_BUS_FMT_YVYU8_2X8:
+	for (i = 0; i < ARRAY_SIZE(modes); ++i) {
+		if (modes[i].mbus_code == mbus_code) {
+			*pixelformats = modes[i].pixelformats;
+			*pixelformats_size = modes[i].pixelformats_size;
 			return true;
-		default:
-			dev_dbg(csi_dev->dev, "Unsupported mbus code: 0x%x\n",
-				mbus_code);
-			break;
 		}
-		break;
-
-	case V4L2_PIX_FMT_RGB565:
-		return (mbus_code == MEDIA_BUS_FMT_RGB565_2X8_LE);
-	case V4L2_PIX_FMT_RGB565X:
-		return (mbus_code == MEDIA_BUS_FMT_RGB565_2X8_BE);
-
-	case V4L2_PIX_FMT_JPEG:
-		return (mbus_code == MEDIA_BUS_FMT_JPEG_1X8);
-
-	default:
-		dev_dbg(csi_dev->dev, "Unsupported pixformat: 0x%x\n",
-			pixformat);
-		break;
 	}
-
 	return false;
 }
 
-int sun6i_csi_set_power(struct sun6i_csi_device *csi_dev, bool enable)
+int sun6i_csi_set_power(struct sun6i_csi *csi, bool enable)
 {
-	struct device *dev = csi_dev->dev;
-	struct regmap *regmap = csi_dev->regmap;
+	struct sun6i_csi_dev *sdev = sun6i_csi_to_dev(csi);
+	struct device *dev = sdev->dev;
+	struct regmap *regmap = sdev->regmap;
 	int ret;
 
 	if (!enable) {
 		regmap_update_bits(regmap, CSI_EN_REG, CSI_EN_CSI_EN, 0);
-		pm_runtime_put(dev);
 
+		clk_disable_unprepare(sdev->clk_ram);
+		if (of_device_is_compatible(dev->of_node,
+					    "allwinner,sun50i-a64-csi"))
+			clk_rate_exclusive_put(sdev->clk_mod);
+		clk_disable_unprepare(sdev->clk_mod);
+		reset_control_assert(sdev->rstc_bus);
 		return 0;
 	}
 
-	ret = pm_runtime_resume_and_get(dev);
-	if (ret < 0)
+	ret = clk_prepare_enable(sdev->clk_mod);
+	if (ret) {
+		dev_err(sdev->dev, "Enable csi clk err %d\n", ret);
 		return ret;
+	}
+
+	if (of_device_is_compatible(dev->of_node, "allwinner,sun50i-a64-csi"))
+		clk_set_rate_exclusive(sdev->clk_mod, 300000000);
+
+	ret = clk_prepare_enable(sdev->clk_ram);
+	if (ret) {
+		dev_err(sdev->dev, "Enable clk_dram_csi clk err %d\n", ret);
+		goto clk_mod_disable;
+	}
+
+	ret = reset_control_deassert(sdev->rstc_bus);
+	if (ret) {
+		dev_err(sdev->dev, "reset err %d\n", ret);
+		goto clk_ram_disable;
+	}
 
 	regmap_update_bits(regmap, CSI_EN_REG, CSI_EN_CSI_EN, CSI_EN_CSI_EN);
 
 	return 0;
+
+clk_ram_disable:
+	clk_disable_unprepare(sdev->clk_ram);
+clk_mod_disable:
+	if (of_device_is_compatible(dev->of_node, "allwinner,sun50i-a64-csi"))
+		clk_rate_exclusive_put(sdev->clk_mod);
+	clk_disable_unprepare(sdev->clk_mod);
+	return ret;
 }
 
-static enum csi_input_fmt get_csi_input_format(struct sun6i_csi_device *csi_dev,
+static enum csi_input_fmt get_csi_input_format(struct sun6i_csi_dev *sdev,
 					       u32 mbus_code, u32 pixformat)
 {
 	/* non-YUV */
@@ -187,13 +198,12 @@
 	}
 
 	/* not support YUV420 input format yet */
-	dev_dbg(csi_dev->dev, "Select YUV422 as default input format of CSI.\n");
+	dev_dbg(sdev->dev, "Select YUV422 as default input format of CSI.\n");
 	return CSI_INPUT_FORMAT_YUV422;
 }
 
-static enum csi_output_fmt
-get_csi_output_format(struct sun6i_csi_device *csi_dev, u32 pixformat,
-		      u32 field)
+static enum csi_output_fmt get_csi_output_format(struct sun6i_csi_dev *sdev,
+						 u32 pixformat, u32 field)
 {
 	bool buf_interlaced = false;
 
@@ -229,6 +239,7 @@
 		return buf_interlaced ? CSI_FRAME_MB_YUV420 :
 					CSI_FIELD_MB_YUV420;
 	case V4L2_PIX_FMT_NV12:
+
 	case V4L2_PIX_FMT_NV21:
 		return buf_interlaced ? CSI_FRAME_UV_CB_YUV420 :
 					CSI_FIELD_UV_CB_YUV420;
@@ -252,14 +263,14 @@
 		return buf_interlaced ? CSI_FRAME_RAW_8 : CSI_FIELD_RAW_8;
 
 	default:
-		dev_warn(csi_dev->dev, "Unsupported pixformat: 0x%x\n", pixformat);
+		dev_warn(sdev->dev, "Unsupported pixformat: 0x%x\n", pixformat);
 		break;
 	}
 
 	return CSI_FIELD_RAW_8;
 }
 
-static enum csi_input_seq get_csi_input_seq(struct sun6i_csi_device *csi_dev,
+static enum csi_input_seq get_csi_input_seq(struct sun6i_csi_dev *sdev,
 					    u32 mbus_code, u32 pixformat)
 {
 	/* Input sequence does not apply to non-YUV formats */
@@ -267,8 +278,8 @@
 		return 0;
 
 	switch (pixformat) {
-	case V4L2_PIX_FMT_NV12_16L16:
 	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV12_16L16:
 	case V4L2_PIX_FMT_NV16:
 	case V4L2_PIX_FMT_YUV420:
 	case V4L2_PIX_FMT_YUV422P:
@@ -286,7 +297,7 @@
 		case MEDIA_BUS_FMT_YVYU8_2X8:
 			return CSI_INPUT_SEQ_YVYU;
 		default:
-			dev_warn(csi_dev->dev, "Unsupported mbus code: 0x%x\n",
+			dev_warn(sdev->dev, "Unsupported mbus code: 0x%x\n",
 				 mbus_code);
 			break;
 		}
@@ -308,7 +319,7 @@
 		case MEDIA_BUS_FMT_YVYU8_2X8:
 			return CSI_INPUT_SEQ_YUYV;
 		default:
-			dev_warn(csi_dev->dev, "Unsupported mbus code: 0x%x\n",
+			dev_warn(sdev->dev, "Unsupported mbus code: 0x%x\n",
 				 mbus_code);
 			break;
 		}
@@ -321,7 +332,7 @@
 		return CSI_INPUT_SEQ_YUYV;
 
 	default:
-		dev_warn(csi_dev->dev, "Unsupported pixformat: 0x%x, defaulting to YUYV\n",
+		dev_warn(sdev->dev, "Unsupported pixformat: 0x%x, defaulting to YUYV\n",
 			 pixformat);
 		break;
 	}
@@ -329,23 +340,23 @@
 	return CSI_INPUT_SEQ_YUYV;
 }
 
-static void sun6i_csi_setup_bus(struct sun6i_csi_device *csi_dev,
-				struct v4l2_fwnode_endpoint *endpoint)
+static void sun6i_csi_setup_bus(struct sun6i_csi_dev *sdev,
+				struct v4l2_fwnode_endpoint* vep)
 {
-	struct sun6i_csi_config *config = &csi_dev->config;
+	struct sun6i_csi *csi = &sdev->csi;
 	unsigned char bus_width;
 	u32 flags;
 	u32 cfg;
 	bool input_interlaced = false;
 
-	if (config->field == V4L2_FIELD_INTERLACED
-	    || config->field == V4L2_FIELD_INTERLACED_TB
-	    || config->field == V4L2_FIELD_INTERLACED_BT)
+	if (csi->config.field == V4L2_FIELD_INTERLACED
+	    || csi->config.field == V4L2_FIELD_INTERLACED_TB
+	    || csi->config.field == V4L2_FIELD_INTERLACED_BT)
 		input_interlaced = true;
 
-	bus_width = endpoint->bus.parallel.bus_width;
+	bus_width = vep->bus.parallel.bus_width;
 
-	regmap_read(csi_dev->regmap, CSI_IF_CFG_REG, &cfg);
+	regmap_read(sdev->regmap, CSI_IF_CFG_REG, &cfg);
 
 	cfg &= ~(CSI_IF_CFG_CSI_IF_MASK | CSI_IF_CFG_MIPI_IF_MASK |
 		 CSI_IF_CFG_IF_DATA_WIDTH_MASK |
@@ -358,11 +369,11 @@
 	else
 		cfg |= CSI_IF_CFG_SRC_TYPE_PROGRESSED;
 
-	switch (endpoint->bus_type) {
+	switch (vep->bus_type) {
 	case V4L2_MBUS_PARALLEL:
 		cfg |= CSI_IF_CFG_MIPI_IF_CSI;
 
-		flags = endpoint->bus.parallel.flags;
+		flags = vep->bus.parallel.flags;
 
 		cfg |= (bus_width == 16) ? CSI_IF_CFG_CSI_IF_YUV422_16BIT :
 					   CSI_IF_CFG_CSI_IF_YUV422_INTLV;
@@ -381,7 +392,7 @@
 	case V4L2_MBUS_BT656:
 		cfg |= CSI_IF_CFG_MIPI_IF_CSI;
 
-		flags = endpoint->bus.parallel.flags;
+		flags = vep->bus.parallel.flags;
 
 		cfg |= (bus_width == 16) ? CSI_IF_CFG_CSI_IF_BT1120 :
 					   CSI_IF_CFG_CSI_IF_BT656;
@@ -393,8 +404,8 @@
 			cfg |= CSI_IF_CFG_CLK_POL_FALLING_EDGE;
 		break;
 	default:
-		dev_warn(csi_dev->dev, "Unsupported bus type: %d\n",
-			 endpoint->bus_type);
+		dev_warn(sdev->dev, "Unsupported bus type: %d\n",
+			 vep->bus_type);
 		break;
 	}
 
@@ -411,54 +422,54 @@
 	case 16: /* No need to configure DATA_WIDTH for 16bit */
 		break;
 	default:
-		dev_warn(csi_dev->dev, "Unsupported bus width: %u\n", bus_width);
+		dev_warn(sdev->dev, "Unsupported bus width: %u\n", bus_width);
 		break;
 	}
 
-	regmap_write(csi_dev->regmap, CSI_IF_CFG_REG, cfg);
+	regmap_write(sdev->regmap, CSI_IF_CFG_REG, cfg);
 }
 
-static void sun6i_csi_set_format(struct sun6i_csi_device *csi_dev)
+static void sun6i_csi_set_format(struct sun6i_csi_dev *sdev)
 {
-	struct sun6i_csi_config *config = &csi_dev->config;
+	struct sun6i_csi *csi = &sdev->csi;
 	u32 cfg;
 	u32 val;
 
-	regmap_read(csi_dev->regmap, CSI_CH_CFG_REG, &cfg);
+	regmap_read(sdev->regmap, CSI_CH_CFG_REG, &cfg);
 
 	cfg &= ~(CSI_CH_CFG_INPUT_FMT_MASK |
 		 CSI_CH_CFG_OUTPUT_FMT_MASK | CSI_CH_CFG_VFLIP_EN |
 		 CSI_CH_CFG_HFLIP_EN | CSI_CH_CFG_FIELD_SEL_MASK |
 		 CSI_CH_CFG_INPUT_SEQ_MASK);
 
-	val = get_csi_input_format(csi_dev, config->code,
-				   config->pixelformat);
+	val = get_csi_input_format(sdev, csi->config.code,
+				   csi->config.pixelformat);
 	cfg |= CSI_CH_CFG_INPUT_FMT(val);
 
-	val = get_csi_output_format(csi_dev, config->pixelformat,
-				    config->field);
+	val = get_csi_output_format(sdev, csi->config.pixelformat,
+				    csi->config.field);
 	cfg |= CSI_CH_CFG_OUTPUT_FMT(val);
 
-	val = get_csi_input_seq(csi_dev, config->code,
-				config->pixelformat);
+	val = get_csi_input_seq(sdev, csi->config.code,
+				csi->config.pixelformat);
 	cfg |= CSI_CH_CFG_INPUT_SEQ(val);
 
-	if (config->field == V4L2_FIELD_TOP)
+	if (csi->config.field == V4L2_FIELD_TOP)
 		cfg |= CSI_CH_CFG_FIELD_SEL_FIELD0;
-	else if (config->field == V4L2_FIELD_BOTTOM)
+	else if (csi->config.field == V4L2_FIELD_BOTTOM)
 		cfg |= CSI_CH_CFG_FIELD_SEL_FIELD1;
 	else
 		cfg |= CSI_CH_CFG_FIELD_SEL_BOTH;
 
-	regmap_write(csi_dev->regmap, CSI_CH_CFG_REG, cfg);
+	regmap_write(sdev->regmap, CSI_CH_CFG_REG, cfg);
 }
 
-static void sun6i_csi_set_window(struct sun6i_csi_device *csi_dev)
+static void sun6i_csi_set_window(struct sun6i_csi_dev *sdev)
 {
-	struct sun6i_csi_config *config = &csi_dev->config;
+	struct sun6i_csi_config *config = &sdev->csi.config;
 	u32 bytesperline_y;
 	u32 bytesperline_c;
-	int *planar_offset = csi_dev->planar_offset;
+	int *planar_offset = sdev->planar_offset;
 	u32 width = config->width;
 	u32 height = config->height;
 	u32 hor_len = width;
@@ -470,7 +481,7 @@
 	case V4L2_PIX_FMT_VYUY:
 	case V4L2_PIX_FMT_RGB565:
 	case V4L2_PIX_FMT_RGB555:
-		dev_dbg(csi_dev->dev,
+		dev_dbg(sdev->dev,
 			"Horizontal length should be 2 times of width for packed YUV formats!\n");
 		hor_len = width * 2;
 		break;
@@ -478,17 +489,17 @@
 		break;
 	}
 
-	regmap_write(csi_dev->regmap, CSI_CH_HSIZE_REG,
+	regmap_write(sdev->regmap, CSI_CH_HSIZE_REG,
 		     CSI_CH_HSIZE_HOR_LEN(hor_len) |
 		     CSI_CH_HSIZE_HOR_START(0));
-	regmap_write(csi_dev->regmap, CSI_CH_VSIZE_REG,
+	regmap_write(sdev->regmap, CSI_CH_VSIZE_REG,
 		     CSI_CH_VSIZE_VER_LEN(height) |
 		     CSI_CH_VSIZE_VER_START(0));
 
 	planar_offset[0] = 0;
 	switch (config->pixelformat) {
-	case V4L2_PIX_FMT_NV12_16L16:
 	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV12_16L16:
 	case V4L2_PIX_FMT_NV21:
 	case V4L2_PIX_FMT_NV16:
 	case V4L2_PIX_FMT_NV61:
@@ -513,53 +524,57 @@
 				bytesperline_c * height;
 		break;
 	default: /* raw */
-		dev_dbg(csi_dev->dev,
+		dev_dbg(sdev->dev,
 			"Calculating pixelformat(0x%x)'s bytesperline as a packed format\n",
 			config->pixelformat);
-		bytesperline_y = csi_dev->video.format.fmt.pix.bytesperline;
+		bytesperline_y = sdev->csi.video.fmt.fmt.pix.bytesperline;
 		bytesperline_c = 0;
 		planar_offset[1] = -1;
 		planar_offset[2] = -1;
 		break;
 	}
 
-	regmap_write(csi_dev->regmap, CSI_CH_BUF_LEN_REG,
+	regmap_write(sdev->regmap, CSI_CH_BUF_LEN_REG,
 		     CSI_CH_BUF_LEN_BUF_LEN_C(bytesperline_c) |
 		     CSI_CH_BUF_LEN_BUF_LEN_Y(bytesperline_y));
 }
 
-int sun6i_csi_update_config(struct sun6i_csi_device *csi_dev,
+int sun6i_csi_update_config(struct sun6i_csi *csi,
 			    struct sun6i_csi_config *config,
-			    struct v4l2_fwnode_endpoint *vep)
+			    struct v4l2_fwnode_endpoint* vep)
 {
+	struct sun6i_csi_dev *sdev = sun6i_csi_to_dev(csi);
+
 	if (!config)
 		return -EINVAL;
 
-	memcpy(&csi_dev->config, config, sizeof(csi_dev->config));
+	memcpy(&csi->config, config, sizeof(csi->config));
 
-	sun6i_csi_setup_bus(csi_dev, vep);
-	sun6i_csi_set_format(csi_dev);
-	sun6i_csi_set_window(csi_dev);
+	sun6i_csi_setup_bus(sdev, vep);
+	sun6i_csi_set_format(sdev);
+	sun6i_csi_set_window(sdev);
 
 	return 0;
 }
 
-void sun6i_csi_update_buf_addr(struct sun6i_csi_device *csi_dev,
-			       dma_addr_t addr)
+void sun6i_csi_update_buf_addr(struct sun6i_csi *csi, dma_addr_t addr)
 {
-	regmap_write(csi_dev->regmap, CSI_CH_F0_BUFA_REG,
-		     (addr + csi_dev->planar_offset[0]) >> 2);
-	if (csi_dev->planar_offset[1] != -1)
-		regmap_write(csi_dev->regmap, CSI_CH_F1_BUFA_REG,
-			     (addr + csi_dev->planar_offset[1]) >> 2);
-	if (csi_dev->planar_offset[2] != -1)
-		regmap_write(csi_dev->regmap, CSI_CH_F2_BUFA_REG,
-			     (addr + csi_dev->planar_offset[2]) >> 2);
+	struct sun6i_csi_dev *sdev = sun6i_csi_to_dev(csi);
+
+	regmap_write(sdev->regmap, CSI_CH_F0_BUFA_REG,
+		     (addr + sdev->planar_offset[0]) >> 2);
+	if (sdev->planar_offset[1] != -1)
+		regmap_write(sdev->regmap, CSI_CH_F1_BUFA_REG,
+			     (addr + sdev->planar_offset[1]) >> 2);
+	if (sdev->planar_offset[2] != -1)
+		regmap_write(sdev->regmap, CSI_CH_F2_BUFA_REG,
+			     (addr + sdev->planar_offset[2]) >> 2);
 }
 
-void sun6i_csi_set_stream(struct sun6i_csi_device *csi_dev, bool enable)
+void sun6i_csi_set_stream(struct sun6i_csi *csi, bool enable)
 {
-	struct regmap *regmap = csi_dev->regmap;
+	struct sun6i_csi_dev *sdev = sun6i_csi_to_dev(csi);
+	struct regmap *regmap = sdev->regmap;
 
 	if (!enable) {
 		regmap_update_bits(regmap, CSI_CAP_REG, CSI_CAP_CH0_VCAP_ON, 0);
@@ -580,45 +595,32 @@
 			   CSI_CAP_CH0_VCAP_ON);
 }
 
-/* Media */
-
-static const struct media_device_ops sun6i_csi_media_ops = {
-	.link_notify = v4l2_pipeline_link_notify,
-};
-
-/* V4L2 */
-
-static int sun6i_csi_link_entity(struct sun6i_csi_device *csi_dev,
-				 struct media_entity *entity,
-				 struct fwnode_handle *fwnode,
-				 u32 link_flags)
-{
-	struct media_entity *sink;
-	struct media_pad *sink_pad;
-	int src_pad_index;
-	int ret;
-
-	ret = media_entity_get_fwnode_pad(entity, fwnode, MEDIA_PAD_FL_SOURCE);
-	if (ret < 0) {
-		dev_err(csi_dev->dev,
-			"%s: no source pad in external entity %s\n", __func__,
-			entity->name);
+/* -----------------------------------------------------------------------------
+ * Media Controller and V4L2
+ */
+static int sun6i_csi_link_subdev(struct sun6i_csi *csi, struct v4l2_subdev *sd,
+				 int link_flags)
+{
+	struct media_entity *source = &sd->entity;
+	struct media_entity *sink = &csi->video.vdev.entity;
+	int src_pad, sink_pad = csi->video.pad.index, ret;
+
+	src_pad = media_entity_get_fwnode_pad(source, sd->fwnode,
+					      MEDIA_PAD_FL_SOURCE);
+	if (src_pad < 0) {
+		dev_err(csi->dev, "%s: no source pad in external entity %s\n",
+			__func__, source->name);
 		return -EINVAL;
 	}
 
-	src_pad_index = ret;
-
-	sink = &csi_dev->video.video_dev.entity;
-	sink_pad = &csi_dev->video.pad;
+	dev_info(csi->dev, "creating %s:%u -> %s:%u link\n",
+		 source->name, src_pad, sink->name, sink_pad);
 
-	dev_dbg(csi_dev->dev, "creating %s:%u -> %s:%u link\n",
-		entity->name, src_pad_index, sink->name, sink_pad->index);
-	ret = media_create_pad_link(entity, src_pad_index, sink,
-				    sink_pad->index, link_flags);
+	ret = media_create_pad_link(source, src_pad, sink, sink_pad,
+				    link_flags);
 	if (ret < 0) {
-		dev_err(csi_dev->dev, "failed to create %s:%u -> %s:%u link\n",
-			entity->name, src_pad_index,
-			sink->name, sink_pad->index);
+		dev_err(csi->dev, "failed to create %s:%u -> %s:%u link\n",
+			source->name, src_pad, sink->name, sink_pad);
 		return ret;
 	}
 
@@ -627,50 +629,60 @@
 
 static int sun6i_subdev_notify_complete(struct v4l2_async_notifier *notifier)
 {
-	struct sun6i_csi_device *csi_dev =
-		container_of(notifier, struct sun6i_csi_device,
-			     v4l2.notifier);
-	struct sun6i_csi_v4l2 *v4l2 = &csi_dev->v4l2;
-	struct v4l2_device *v4l2_dev = &v4l2->v4l2_dev;
-	u32 link_flags = MEDIA_LNK_FL_ENABLED;
+	struct sun6i_csi *csi = container_of(notifier, struct sun6i_csi,
+					     notifier);
+	struct v4l2_device *v4l2_dev = &csi->v4l2_dev;
 	struct v4l2_subdev *sd;
-	int ret;
+	int ret, link_flags = MEDIA_LNK_FL_ENABLED;
 
-	dev_dbg(csi_dev->dev, "notify complete, all subdevs registered\n");
+	dev_dbg(csi->dev, "notify complete, all subdevs registered\n");
 
-	if (list_empty(&v4l2_dev->subdevs))
-		return -EINVAL;
+	ret = v4l2_device_register_subdev_nodes(&csi->v4l2_dev);
+	if (ret < 0)
+		return ret;
 
+	// link subdevs source pads to the controller sink pad, enable
+	// the first link
 	list_for_each_entry(sd, &v4l2_dev->subdevs, list) {
-		ret = sun6i_csi_link_entity(csi_dev, &sd->entity,
-					    sd->fwnode, link_flags);
+		ret = sun6i_csi_link_subdev(csi, sd, link_flags);
 		if (ret < 0)
 			return ret;
 
-		/* only enable the first link */
 		link_flags = 0;
 	}
 
-	ret = v4l2_device_register_subdev_nodes(v4l2_dev);
-	if (ret < 0)
-		return ret;
-
-	return 0;
+	return media_device_register(&csi->media_dev);
 }
 
 static const struct v4l2_async_notifier_operations sun6i_csi_async_ops = {
 	.complete = sun6i_subdev_notify_complete,
 };
 
+static const struct media_device_ops sun6i_csi_media_ops = {
+	.link_notify = v4l2_pipeline_link_notify,
+};
+
+/* CSI module has one port that can support multiple endpoints.
+ * Typically front and back camera on a tablet.
+ *
+ * Multiple endpoints are supported by selectively enabling only
+ * one of the endpoint devices at a time and shutting down the
+ * rest.
+ */
 static int sun6i_csi_fwnode_parse(struct device *dev,
 				  struct v4l2_fwnode_endpoint *vep,
 				  struct v4l2_async_subdev *asd)
 {
-	struct sun6i_csi_async_subdev *casd =
+	struct sun6i_csi_async_subdev* casd =
 		container_of(asd, struct sun6i_csi_async_subdev, asd);
 
 	if (vep->base.port) {
-		dev_err(dev, "Only remote entities with a single port are supported\n");
+		dev_warn(dev, "Too many ports\n");
+		return -ENOTCONN;
+	}
+
+	if (vep->base.id >= MAX_ENDPOINTS) {
+		dev_warn(dev, "Too many endpoints\n");
 		return -ENOTCONN;
 	}
 
@@ -680,107 +692,95 @@
 		casd->vep = *vep;
 		return 0;
 	default:
-		dev_err(dev, "Unsupported media bus type\n");
+		dev_warn(dev, "Unsupported media bus type\n");
 		return -ENOTCONN;
 	}
 }
 
-static int sun6i_csi_v4l2_setup(struct sun6i_csi_device *csi_dev)
+static void sun6i_csi_v4l2_cleanup(struct sun6i_csi *csi)
 {
-	struct sun6i_csi_v4l2 *v4l2 = &csi_dev->v4l2;
-	struct media_device *media_dev = &v4l2->media_dev;
-	struct v4l2_device *v4l2_dev = &v4l2->v4l2_dev;
-	struct v4l2_async_notifier *notifier = &v4l2->notifier;
-	struct device *dev = csi_dev->dev;
-	int ret;
+	media_device_unregister(&csi->media_dev);
+	v4l2_async_nf_unregister(&csi->notifier);
+	v4l2_async_nf_cleanup(&csi->notifier);
+	sun6i_video_cleanup(&csi->video);
+	v4l2_device_unregister(&csi->v4l2_dev);
+	v4l2_ctrl_handler_free(&csi->ctrl_handler);
+	media_device_cleanup(&csi->media_dev);
+}
 
-	/* Media Device */
+static int sun6i_csi_v4l2_init(struct sun6i_csi *csi)
+{
+	int ret;
 
-	strscpy(media_dev->model, SUN6I_CSI_DESCRIPTION,
-		sizeof(media_dev->model));
-	media_dev->hw_revision = 0;
-	media_dev->ops = &sun6i_csi_media_ops;
-	media_dev->dev = dev;
+	csi->media_dev.dev = csi->dev;
+	strscpy(csi->media_dev.model, "Allwinner Video Capture Device",
+		sizeof(csi->media_dev.model));
+	csi->media_dev.hw_revision = 0;
+	csi->media_dev.ops = &sun6i_csi_media_ops;
+	snprintf(csi->media_dev.bus_info, sizeof(csi->media_dev.bus_info),
+		 "platform:%s", dev_name(csi->dev));
 
-	media_device_init(media_dev);
+	media_device_init(&csi->media_dev);
+	v4l2_async_nf_init(&csi->notifier);
 
-	ret = media_device_register(media_dev);
+	/*
+	ret = v4l2_ctrl_handler_init(&csi->ctrl_handler, 0);
 	if (ret) {
-		dev_err(dev, "failed to register media device: %d\n", ret);
-		goto error_media;
+		dev_err(csi->dev, "V4L2 controls handler init failed (%d)\n",
+			ret);
+		goto clean_media;
 	}
-
-	/* V4L2 Device */
-
-	v4l2_dev->mdev = media_dev;
-
-	ret = v4l2_device_register(dev, v4l2_dev);
+          */
+	csi->v4l2_dev.mdev = &csi->media_dev;
+	//csi->v4l2_dev.ctrl_handler = &csi->ctrl_handler;
+	ret = v4l2_device_register(csi->dev, &csi->v4l2_dev);
 	if (ret) {
-		dev_err(dev, "failed to register v4l2 device: %d\n", ret);
-		goto error_media;
+		dev_err(csi->dev, "V4L2 device registration failed (%d)\n",
+			ret);
+		goto free_ctrl;
 	}
 
-	/* Video */
-
-	ret = sun6i_video_setup(csi_dev);
+	ret = sun6i_video_init(&csi->video, csi, "sun6i-csi");
 	if (ret)
-		goto error_v4l2_device;
-
-	/* V4L2 Async */
+		goto unreg_v4l2;
 
-	v4l2_async_nf_init(notifier);
-	notifier->ops = &sun6i_csi_async_ops;
-
-	ret = v4l2_async_nf_parse_fwnode_endpoints(dev, notifier,
-						   sizeof(struct
-							  sun6i_csi_async_subdev),
-						   sun6i_csi_fwnode_parse);
+	ret = v4l2_async_nf_parse_fwnode_endpoints(csi->dev,
+					 &csi->notifier,
+					 sizeof(struct sun6i_csi_async_subdev),
+					 sun6i_csi_fwnode_parse);
 	if (ret)
-		goto error_video;
+		goto clean_video;
+
+	csi->notifier.ops = &sun6i_csi_async_ops;
 
-	ret = v4l2_async_nf_register(v4l2_dev, notifier);
+	ret = v4l2_async_nf_register(&csi->v4l2_dev, &csi->notifier);
 	if (ret) {
-		dev_err(dev, "failed to register v4l2 async notifier: %d\n",
-			ret);
-		goto error_v4l2_async_notifier;
+		dev_err(csi->dev, "notifier registration failed\n");
+		goto clean_video;
 	}
 
 	return 0;
 
-error_v4l2_async_notifier:
-	v4l2_async_nf_cleanup(notifier);
-
-error_video:
-	sun6i_video_cleanup(csi_dev);
-
-error_v4l2_device:
-	v4l2_device_unregister(&v4l2->v4l2_dev);
-
-error_media:
-	media_device_unregister(media_dev);
-	media_device_cleanup(media_dev);
+clean_video:
+	sun6i_video_cleanup(&csi->video);
+unreg_v4l2:
+	v4l2_device_unregister(&csi->v4l2_dev);
+free_ctrl:
+	//v4l2_ctrl_handler_free(&csi->ctrl_handler);
+clean_media:
+	v4l2_async_nf_cleanup(&csi->notifier);
+	media_device_cleanup(&csi->media_dev);
 
 	return ret;
 }
 
-static void sun6i_csi_v4l2_cleanup(struct sun6i_csi_device *csi_dev)
-{
-	struct sun6i_csi_v4l2 *v4l2 = &csi_dev->v4l2;
-
-	media_device_unregister(&v4l2->media_dev);
-	v4l2_async_nf_unregister(&v4l2->notifier);
-	v4l2_async_nf_cleanup(&v4l2->notifier);
-	sun6i_video_cleanup(csi_dev);
-	v4l2_device_unregister(&v4l2->v4l2_dev);
-	media_device_cleanup(&v4l2->media_dev);
-}
-
-/* Platform */
-
-static irqreturn_t sun6i_csi_interrupt(int irq, void *private)
+/* -----------------------------------------------------------------------------
+ * Resources and IRQ
+ */
+static irqreturn_t sun6i_csi_isr(int irq, void *dev_id)
 {
-	struct sun6i_csi_device *csi_dev = private;
-	struct regmap *regmap = csi_dev->regmap;
+	struct sun6i_csi_dev *sdev = (struct sun6i_csi_dev *)dev_id;
+	struct regmap *regmap = sdev->regmap;
 	u32 status;
 
 	regmap_read(regmap, CSI_CH_INT_STA_REG, &status);
@@ -800,63 +800,13 @@
 	}
 
 	if (status & CSI_CH_INT_STA_FD_PD)
-		sun6i_video_frame_done(csi_dev);
+		sun6i_video_frame_done(&sdev->csi.video);
 
 	regmap_write(regmap, CSI_CH_INT_STA_REG, status);
 
 	return IRQ_HANDLED;
 }
 
-static int sun6i_csi_suspend(struct device *dev)
-{
-	struct sun6i_csi_device *csi_dev = dev_get_drvdata(dev);
-
-	reset_control_assert(csi_dev->reset);
-	clk_disable_unprepare(csi_dev->clock_ram);
-	clk_disable_unprepare(csi_dev->clock_mod);
-
-	return 0;
-}
-
-static int sun6i_csi_resume(struct device *dev)
-{
-	struct sun6i_csi_device *csi_dev = dev_get_drvdata(dev);
-	int ret;
-
-	ret = reset_control_deassert(csi_dev->reset);
-	if (ret) {
-		dev_err(dev, "failed to deassert reset\n");
-		return ret;
-	}
-
-	ret = clk_prepare_enable(csi_dev->clock_mod);
-	if (ret) {
-		dev_err(dev, "failed to enable module clock\n");
-		goto error_reset;
-	}
-
-	ret = clk_prepare_enable(csi_dev->clock_ram);
-	if (ret) {
-		dev_err(dev, "failed to enable ram clock\n");
-		goto error_clock_mod;
-	}
-
-	return 0;
-
-error_clock_mod:
-	clk_disable_unprepare(csi_dev->clock_mod);
-
-error_reset:
-	reset_control_assert(csi_dev->reset);
-
-	return ret;
-}
-
-static const struct dev_pm_ops sun6i_csi_pm_ops = {
-	.runtime_suspend	= sun6i_csi_suspend,
-	.runtime_resume		= sun6i_csi_resume,
-};
-
 static const struct regmap_config sun6i_csi_regmap_config = {
 	.reg_bits       = 32,
 	.reg_stride     = 4,
@@ -864,181 +814,108 @@
 	.max_register	= 0x9c,
 };
 
-static int sun6i_csi_resources_setup(struct sun6i_csi_device *csi_dev,
-				     struct platform_device *platform_dev)
+static int sun6i_csi_resource_request(struct sun6i_csi_dev *sdev,
+				      struct platform_device *pdev)
 {
-	struct device *dev = csi_dev->dev;
-	const struct sun6i_csi_variant *variant;
+	struct resource *res;
 	void __iomem *io_base;
 	int ret;
 	int irq;
 
-	variant = of_device_get_match_data(dev);
-	if (!variant)
-		return -EINVAL;
-
-	/* Registers */
-
-	io_base = devm_platform_ioremap_resource(platform_dev, 0);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	io_base = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(io_base))
 		return PTR_ERR(io_base);
 
-	csi_dev->regmap = devm_regmap_init_mmio_clk(dev, "bus", io_base,
-						    &sun6i_csi_regmap_config);
-	if (IS_ERR(csi_dev->regmap)) {
-		dev_err(dev, "failed to init register map\n");
-		return PTR_ERR(csi_dev->regmap);
-	}
-
-	/* Clocks */
-
-	csi_dev->clock_mod = devm_clk_get(dev, "mod");
-	if (IS_ERR(csi_dev->clock_mod)) {
-		dev_err(dev, "failed to acquire module clock\n");
-		return PTR_ERR(csi_dev->clock_mod);
+	sdev->regmap = devm_regmap_init_mmio_clk(&pdev->dev, "bus", io_base,
+						 &sun6i_csi_regmap_config);
+	if (IS_ERR(sdev->regmap)) {
+		dev_err(&pdev->dev, "Failed to init register map\n");
+		return PTR_ERR(sdev->regmap);
 	}
 
-	csi_dev->clock_ram = devm_clk_get(dev, "ram");
-	if (IS_ERR(csi_dev->clock_ram)) {
-		dev_err(dev, "failed to acquire ram clock\n");
-		return PTR_ERR(csi_dev->clock_ram);
+	sdev->clk_mod = devm_clk_get(&pdev->dev, "mod");
+	if (IS_ERR(sdev->clk_mod)) {
+		dev_err(&pdev->dev, "Unable to acquire csi clock\n");
+		return PTR_ERR(sdev->clk_mod);
 	}
 
-	ret = clk_set_rate_exclusive(csi_dev->clock_mod,
-				     variant->clock_mod_rate);
-	if (ret) {
-		dev_err(dev, "failed to set mod clock rate\n");
-		return ret;
+	sdev->clk_ram = devm_clk_get(&pdev->dev, "ram");
+	if (IS_ERR(sdev->clk_ram)) {
+		dev_err(&pdev->dev, "Unable to acquire dram-csi clock\n");
+		return PTR_ERR(sdev->clk_ram);
 	}
 
-	/* Reset */
-
-	csi_dev->reset = devm_reset_control_get_shared(dev, NULL);
-	if (IS_ERR(csi_dev->reset)) {
-		dev_err(dev, "failed to acquire reset\n");
-		ret = PTR_ERR(csi_dev->reset);
-		goto error_clock_rate_exclusive;
+	sdev->rstc_bus = devm_reset_control_get_shared(&pdev->dev, NULL);
+	if (IS_ERR(sdev->rstc_bus)) {
+		dev_err(&pdev->dev, "Cannot get reset controller\n");
+		return PTR_ERR(sdev->rstc_bus);
 	}
 
-	/* Interrupt */
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return -ENXIO;
 
-	irq = platform_get_irq(platform_dev, 0);
-	if (irq < 0) {
-		dev_err(dev, "failed to get interrupt\n");
-		ret = -ENXIO;
-		goto error_clock_rate_exclusive;
-	}
-
-	ret = devm_request_irq(dev, irq, sun6i_csi_interrupt, 0, SUN6I_CSI_NAME,
-			       csi_dev);
+	ret = devm_request_irq(&pdev->dev, irq, sun6i_csi_isr, 0, MODULE_NAME,
+			       sdev);
 	if (ret) {
-		dev_err(dev, "failed to request interrupt\n");
-		goto error_clock_rate_exclusive;
+		dev_err(&pdev->dev, "Cannot request csi IRQ\n");
+		return ret;
 	}
 
-	/* Runtime PM */
-
-	pm_runtime_enable(dev);
-
 	return 0;
-
-error_clock_rate_exclusive:
-	clk_rate_exclusive_put(csi_dev->clock_mod);
-
-	return ret;
-}
-
-static void sun6i_csi_resources_cleanup(struct sun6i_csi_device *csi_dev)
-{
-	pm_runtime_disable(csi_dev->dev);
-	clk_rate_exclusive_put(csi_dev->clock_mod);
 }
 
-static int sun6i_csi_probe(struct platform_device *platform_dev)
+static int sun6i_csi_probe(struct platform_device *pdev)
 {
-	struct sun6i_csi_device *csi_dev;
-	struct device *dev = &platform_dev->dev;
+	struct sun6i_csi_dev *sdev;
 	int ret;
 
-	csi_dev = devm_kzalloc(dev, sizeof(*csi_dev), GFP_KERNEL);
-	if (!csi_dev)
+	sdev = devm_kzalloc(&pdev->dev, sizeof(*sdev), GFP_KERNEL);
+	if (!sdev)
 		return -ENOMEM;
 
-	csi_dev->dev = &platform_dev->dev;
-	platform_set_drvdata(platform_dev, csi_dev);
+	sdev->dev = &pdev->dev;
 
-	ret = sun6i_csi_resources_setup(csi_dev, platform_dev);
+	ret = sun6i_csi_resource_request(sdev, pdev);
 	if (ret)
 		return ret;
 
-	ret = sun6i_csi_v4l2_setup(csi_dev);
-	if (ret)
-		goto error_resources;
-
-	return 0;
-
-error_resources:
-	sun6i_csi_resources_cleanup(csi_dev);
+	platform_set_drvdata(pdev, sdev);
 
-	return ret;
+	sdev->csi.dev = &pdev->dev;
+	return sun6i_csi_v4l2_init(&sdev->csi);
 }
 
 static int sun6i_csi_remove(struct platform_device *pdev)
 {
-	struct sun6i_csi_device *csi_dev = platform_get_drvdata(pdev);
+	struct sun6i_csi_dev *sdev = platform_get_drvdata(pdev);
 
-	sun6i_csi_v4l2_cleanup(csi_dev);
-	sun6i_csi_resources_cleanup(csi_dev);
+	sun6i_csi_v4l2_cleanup(&sdev->csi);
 
 	return 0;
 }
 
-static const struct sun6i_csi_variant sun6i_a31_csi_variant = {
-	.clock_mod_rate	= 297000000,
-};
-
-static const struct sun6i_csi_variant sun50i_a64_csi_variant = {
-	.clock_mod_rate	= 300000000,
-};
-
 static const struct of_device_id sun6i_csi_of_match[] = {
-	{
-		.compatible	= "allwinner,sun6i-a31-csi",
-		.data		= &sun6i_a31_csi_variant,
-	},
-	{
-		.compatible	= "allwinner,sun8i-a83t-csi",
-		.data		= &sun6i_a31_csi_variant,
-	},
-	{
-		.compatible	= "allwinner,sun8i-h3-csi",
-		.data		= &sun6i_a31_csi_variant,
-	},
-	{
-		.compatible	= "allwinner,sun8i-v3s-csi",
-		.data		= &sun6i_a31_csi_variant,
-	},
-	{
-		.compatible	= "allwinner,sun50i-a64-csi",
-		.data		= &sun50i_a64_csi_variant,
-	},
+	{ .compatible = "allwinner,sun6i-a31-csi", },
+	{ .compatible = "allwinner,sun8i-a83t-csi", },
+	{ .compatible = "allwinner,sun8i-h3-csi", },
+	{ .compatible = "allwinner,sun8i-v3s-csi", },
+	{ .compatible = "allwinner,sun50i-a64-csi", },
 	{},
 };
-
 MODULE_DEVICE_TABLE(of, sun6i_csi_of_match);
 
 static struct platform_driver sun6i_csi_platform_driver = {
-	.probe	= sun6i_csi_probe,
-	.remove	= sun6i_csi_remove,
-	.driver	= {
-		.name		= SUN6I_CSI_NAME,
-		.of_match_table	= of_match_ptr(sun6i_csi_of_match),
-		.pm		= &sun6i_csi_pm_ops,
+	.probe = sun6i_csi_probe,
+	.remove = sun6i_csi_remove,
+	.driver = {
+		.name = MODULE_NAME,
+		.of_match_table = of_match_ptr(sun6i_csi_of_match),
 	},
 };
-
 module_platform_driver(sun6i_csi_platform_driver);
 
-MODULE_DESCRIPTION("Allwinner A31 Camera Sensor Interface driver");
+MODULE_DESCRIPTION("Allwinner V3s Camera Sensor Interface driver");
 MODULE_AUTHOR("Yong Deng <yong.deng@magewell.com>");
 MODULE_LICENSE("GPL");
